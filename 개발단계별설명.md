# Mustache 템플릿 엔진 수업 - 단계별 개발 가이드

## 안녕하세요! 👋

이 수업은 **정말 처음부터** 설명합니다. 
- Java를 조금 알고 있지만 Spring은 처음이신가요?
- getter, setter가 뭔지 모르시나요?
- 어노테이션이 뭔지 모르시나요?

괜찮습니다! 이 수업을 따라하시면 다 이해하실 수 있습니다.

---

## 🎯 오늘 만들 것: 게시글을 저장할 수 있는 클래스 만들기

게시글에는 어떤 정보가 필요할까요?
- 제목
- 내용  
- 작성자
- 작성 시간
- 고유 번호 (1번 게시글, 2번 게시글...)

이런 정보를 담을 수 있는 클래스를 만들어봅시다!

---

## 1단계: 클래스 만들기

### 왜 클래스가 필요한가요?

게시글 하나를 저장하려면:
- 제목: "안녕하세요"
- 내용: "반가워요"
- 작성자: "홍길동"

이런 정보들을 하나로 묶어서 관리해야 합니다. 
그 묶음이 바로 **클래스**입니다!

### 클래스를 만들어봅시다

먼저 파일을 만들어야 합니다.

**파일 위치**: `src/main/java/org/example/demo_ssr_v1_1/board/Board.java`

파일을 만들고 첫 줄을 써봅시다:

```java
package org.example.demo_ssr_v1_1.board;
```

**이게 뭔가요?**
- `package`: "이 파일이 어느 폴더에 있는지 알려주는 것"
- `org.example.demo_ssr_v1_1.board`: 폴더 경로를 나타냄
- **왜 필요한가요?** Java는 파일이 어디에 있는지 정확히 알아야 해요

다음으로 클래스를 선언합니다:

```java
public class Board {
    
}
```

**이게 뭔가요?**
- `public`: "누구나 사용할 수 있어요"
- `class`: "이건 클래스예요"
- `Board`: 클래스 이름 (게시판 = Board)
- `{ }`: 클래스의 내용을 담는 중괄호

지금까지 작성한 코드:

```java
package org.example.demo_ssr_v1_1.board;

public class Board {
    
}
```

좋아요! 빈 클래스가 만들어졌습니다. 이제 게시글에 필요한 정보들을 넣어봅시다.

---

## 2단계: 게시글에 필요한 정보 넣기

### 게시글 고유 번호가 필요해요

게시글이 여러 개 있으면 구분이 필요합니다.
- 1번 게시글
- 2번 게시글
- 3번 게시글

이런 번호를 저장할 변수가 필요합니다.

```java
private Long id;
```

**이게 뭔가요?**
- `private`: "이 클래스 안에서만 사용할 수 있어요" (보안을 위해)
- `Long`: 큰 정수를 저장하는 타입 (1, 2, 3, 100, 1000...)
- `id`: 변수 이름 (고유 번호를 저장)

**왜 Long을 쓰나요?**
- `int`도 있지만, 게시글이 많아질 수 있어서 더 큰 숫자를 담을 수 있는 `Long`을 씁니다

### 이 번호는 자동으로 만들어져야 해요

게시글을 새로 만들 때마다 번호를 직접 지정하면:
- 실수로 같은 번호를 쓸 수 있어요
- 번호를 기억해야 해요

그래서 **자동으로 번호를 만들어주는 기능**이 필요합니다!

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

**`@Id`가 뭔가요?**
- `@`: 어노테이션 (특별한 표시)
- `Id`: "이게 기본 키(Primary Key)예요"
- **기본 키란?** 각 게시글을 구분하는 고유한 번호

**왜 @Id를 붙여야 하나요?**
- 데이터베이스는 "어느 필드가 고유 번호인지" 알아야 해요
- `@Id`를 붙이면 "이게 고유 번호야!"라고 알려주는 거예요

**`@GeneratedValue`가 뭔가요?**
- `Generated`: 생성된
- `Value`: 값
- **의미**: "이 값은 자동으로 생성해줘"

**`strategy = GenerationType.IDENTITY`가 뭔가요?**
- `strategy`: 전략, 방법
- `GenerationType.IDENTITY`: "데이터베이스가 자동으로 1, 2, 3... 순서대로 만들어줘"
- **결과**: 새 게시글을 만들면 자동으로 번호가 부여됩니다!

### 제목이 필요해요

```java
private String title;
```

**이게 뭔가요?**
- `String`: 텍스트(문자열)를 저장하는 타입
- `title`: 변수 이름 (제목)
- **예시**: "안녕하세요", "오늘 날씨 좋네요" 같은 텍스트를 저장

### 내용이 필요해요

```java
private String content;
```

**이게 뭔가요?**
- `content`: 내용을 저장하는 변수
- **예시**: "반가워요", "오늘 정말 좋은 하루였어요" 같은 긴 텍스트를 저장

### 작성자가 필요해요

```java
private String username;
```

**이게 뭔가요?**
- `username`: 작성자 이름을 저장하는 변수
- **예시**: "홍길동", "김철수" 같은 이름을 저장

### 작성 시간이 필요해요

게시글이 언제 작성되었는지 기록해야 합니다.

```java
private Timestamp createdAt;
```

**이게 뭔가요?**
- `Timestamp`: 날짜와 시간을 저장하는 타입
- `createdAt`: 생성된 시간 (created = 생성된, At = ~에)
- **예시**: 2024-01-15 10:30:00 같은 날짜와 시간

**그런데 이 시간도 자동으로 저장되면 좋겠어요!**

사용자가 직접 시간을 입력하면:
- 실수로 잘못된 시간을 입력할 수 있어요
- 매번 시간을 입력해야 해요

그래서 **자동으로 현재 시간을 저장**하는 기능이 필요합니다!

```java
@CreationTimestamp
private Timestamp createdAt;
```

**`@CreationTimestamp`가 뭔가요?**
- `Creation`: 생성
- `Timestamp`: 시간
- **의미**: "데이터가 생성될 때 자동으로 현재 시간을 저장해줘"
- **결과**: 게시글을 저장하면 자동으로 작성 시간이 기록됩니다!

### 지금까지 작성한 코드

```java
package org.example.demo_ssr_v1_1.board;

public class Board {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String title;
    private String content;
    private String username;
    
    @CreationTimestamp
    private Timestamp createdAt;
    
}
```

좋아요! 게시글에 필요한 정보들이 모두 들어갔습니다.

하지만 아직 뭔가 부족해요. 이 클래스를 사용하려면 몇 가지가 더 필요합니다.

---

## 3단계: 필요한 도구들 가져오기 (import)

### 왜 import가 필요한가요?

우리가 사용한 것들:
- `@Id`, `@GeneratedValue` → JPA라는 도구에서 가져옴
- `@CreationTimestamp` → Hibernate라는 도구에서 가져옴
- `Timestamp` → Java에서 가져옴

이런 도구들을 사용하려면 **"이 도구를 사용하겠다"**고 선언해야 해요.
그게 바로 `import`입니다!

파일 맨 위에 import를 추가합니다:

```java
package org.example.demo_ssr_v1_1.board;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import java.sql.Timestamp;

public class Board {
    // ...
}
```

**각 import가 뭔가요?**

1. **`import jakarta.persistence.*;`**
   - `jakarta.persistence`: JPA (데이터베이스 도구)
   - `*`: 모든 것 (Id, GeneratedValue, Entity 등을 포함)
   - **왜 필요한가요?** `@Id`, `@GeneratedValue`를 사용하려면 필요해요

2. **`import lombok.Data;`**
   - `lombok`: 코드를 간단하게 만들어주는 도구
   - `Data`: getter, setter를 자동으로 만들어주는 기능
   - **왜 필요한가요?** 나중에 설명할게요!

3. **`import lombok.NoArgsConstructor;`**
   - `NoArgsConstructor`: 매개변수 없는 생성자를 만들어주는 기능
   - **왜 필요한가요?** 나중에 설명할게요!

4. **`import org.hibernate.annotations.CreationTimestamp;`**
   - `hibernate`: JPA를 실제로 동작하게 하는 도구
   - `CreationTimestamp`: 자동으로 시간을 저장하는 기능
   - **왜 필요한가요?** `@CreationTimestamp`를 사용하려면 필요해요

5. **`import java.sql.Timestamp;`**
   - `java.sql`: Java의 데이터베이스 관련 도구
   - `Timestamp`: 날짜와 시간을 저장하는 타입
   - **왜 필요한가요?** `Timestamp` 타입을 사용하려면 필요해요

---

## 4단계: Getter와 Setter 이해하기

### Getter와 Setter가 뭔가요?

우리가 만든 변수들은 `private`로 되어 있어요:
```java
private String title;
```

**`private`이면 어떻게 되나요?**
- 다른 클래스에서 직접 접근할 수 없어요
- 예: `board.title = "안녕"` ← 이렇게 할 수 없어요!

**그럼 어떻게 값을 넣고 가져오나요?**
- **Setter**: 값을 넣는 메서드
- **Getter**: 값을 가져오는 메서드

### Setter 예시

```java
public void setTitle(String title) {
    this.title = title;
}
```

**이게 뭔가요?**
- `public void`: 누구나 사용할 수 있고, 반환값이 없는 메서드
- `setTitle`: "제목을 설정하는 메서드"
- `String title`: 설정할 제목을 받는 매개변수
- `this.title = title`: 받은 제목을 저장

**사용 예시:**
```java
Board board = new Board();
board.setTitle("안녕하세요");  // Setter로 제목 설정
```

### Getter 예시

```java
public String getTitle() {
    return this.title;
}
```

**이게 뭔가요?**
- `public String`: 누구나 사용할 수 있고, String을 반환하는 메서드
- `getTitle`: "제목을 가져오는 메서드"
- `return this.title`: 저장된 제목을 반환

**사용 예시:**
```java
String 제목 = board.getTitle();  // Getter로 제목 가져오기
System.out.println(제목);  // "안녕하세요" 출력
```

### 그런데 Getter/Setter를 일일이 만들면 너무 길어요!

변수가 5개면:
- Getter 5개
- Setter 5개
- 총 10개의 메서드를 만들어야 해요!

**해결책: `@Data` 사용!**

```java
@Data
public class Board {
    // ...
}
```

**`@Data`가 뭔가요?**
- Lombok이라는 도구의 기능
- **의미**: "이 클래스의 모든 변수에 대해 Getter와 Setter를 자동으로 만들어줘"
- **결과**: 
  - `getTitle()`, `setTitle()`
  - `getContent()`, `setContent()`
  - `getUsername()`, `setUsername()`
  - `getId()`, `setId()`
  - `getCreatedAt()`, `setCreatedAt()`
  - 모두 자동으로 만들어집니다!

**왜 이렇게 하나요?**
- 코드가 훨씬 짧아져요
- 실수로 빼먹을 일이 없어요
- 자동으로 만들어주니까 편해요!

---

## 5단계: 생성자 이해하기

### 생성자가 뭔가요?

객체를 만들 때 사용하는 특별한 메서드입니다.

**예시:**
```java
Board board = new Board();
```

여기서 `Board()`가 생성자입니다!

### 매개변수 없는 생성자가 필요해요

```java
public Board() {
    // 아무것도 안 함
}
```

**이게 뭔가요?**
- `public Board()`: 매개변수가 없는 생성자
- **왜 필요한가요?** JPA(데이터베이스 도구)가 객체를 만들 때 필요해요

**그런데 이것도 자동으로 만들어주면 좋겠어요!**

```java
@NoArgsConstructor
public class Board {
    // ...
}
```

**`@NoArgsConstructor`가 뭔가요?**
- `NoArgsConstructor`: 매개변수 없는 생성자
- **의미**: "매개변수 없는 생성자를 자동으로 만들어줘"
- **결과**: `public Board() { }`가 자동으로 만들어집니다!

### 매개변수 있는 생성자도 필요해요

게시글을 만들 때 제목, 내용, 작성자를 바로 넣고 싶어요:

```java
public Board(String title, String content, String username) {
    this.title = title;
    this.content = content;
    this.username = username;
}
```

**이게 뭔가요?**
- `public Board(...)`: 매개변수가 있는 생성자
- `String title, String content, String username`: 받을 데이터들
- `this.title = title`: 받은 제목을 저장
- **사용 예시:**
  ```java
  Board board = new Board("안녕하세요", "반가워요", "홍길동");
  // 제목, 내용, 작성자가 한 번에 설정됨!
  ```

이 생성자는 직접 만들어야 해요 (자동 생성 안 됨).

---

## 6단계: 데이터베이스와 연결하기

### 왜 데이터베이스와 연결해야 하나요?

우리가 만든 클래스는 지금까지 그냥 Java 클래스예요.
데이터베이스에 저장하려면 **"이 클래스가 데이터베이스 테이블과 연결된다"**고 알려줘야 해요!

### @Entity 붙이기

```java
@Entity
public class Board {
    // ...
}
```

**`@Entity`가 뭔가요?**
- `Entity`: 엔티티 (데이터베이스 테이블과 연결되는 클래스)
- **의미**: "이 클래스는 데이터베이스 테이블과 연결되는 엔티티예요"
- **왜 필요한가요?** JPA가 이 클래스를 데이터베이스와 연결해줘요

### 테이블 이름 지정하기

데이터베이스에는 `board_tb`라는 테이블이 있어요.
하지만 우리 클래스 이름은 `Board`예요.

**이름이 다른데 어떻게 연결하나요?**

```java
@Table(name = "board_tb")
@Entity
public class Board {
    // ...
}
```

**`@Table(name = "board_tb")`가 뭔가요?**
- `Table`: 테이블
- `name = "board_tb"`: 테이블 이름이 "board_tb"예요
- **의미**: "이 엔티티는 `board_tb`라는 테이블과 연결돼요"
- **왜 필요한가요?** 클래스 이름과 테이블 이름이 다르니까 명시해줘야 해요

---

## 7단계: 완성된 코드 확인하기

지금까지 만든 코드를 모두 모아봅시다:

```java
package org.example.demo_ssr_v1_1.board;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import java.sql.Timestamp;

@Data
@NoArgsConstructor
@Table(name = "board_tb")
@Entity
public class Board {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String title;
    private String content;
    private String username;
    
    @CreationTimestamp
    private Timestamp createdAt;
    
    public Board(String title, String content, String username) {
        this.title = title;
        this.content = content;
        this.username = username;
    }
}
```

### 코드 하나하나 다시 정리

1. **`package`**: 파일 위치 알려주기
2. **`import`**: 필요한 도구들 가져오기
3. **`@Data`**: Getter, Setter 자동 생성
4. **`@NoArgsConstructor`**: 매개변수 없는 생성자 자동 생성
5. **`@Table(name = "board_tb")`**: 테이블 이름 지정
6. **`@Entity`**: 데이터베이스와 연결
7. **`@Id`**: 고유 번호 지정
8. **`@GeneratedValue`**: 번호 자동 생성
9. **`@CreationTimestamp`**: 시간 자동 저장
10. **변수들**: 게시글에 필요한 정보들
11. **생성자**: 게시글을 만들 때 사용

---

## 🎉 목표 1 완료!

이제 게시글 데이터를 저장할 수 있는 클래스가 완성되었습니다!

### 배운 것들

1. **클래스**: 데이터를 묶어서 관리하는 것
2. **변수**: 데이터를 저장하는 것
3. **Getter/Setter**: 변수에 값을 넣고 가져오는 메서드
4. **생성자**: 객체를 만들 때 사용하는 메서드
5. **어노테이션**: 특별한 표시 (`@`로 시작)
6. **Entity**: 데이터베이스와 연결되는 클래스

### 다음 수업에서는?

게시글 목록을 보여주는 기능을 만들어봅시다!
- 데이터베이스에서 게시글들을 가져와서
- 화면에 목록으로 보여주는 것

다음 수업에서 만나요! 👋

---

# 목표 2: 게시글 목록 보기

## 🎯 오늘 만들 것: 게시글 목록을 화면에 보여주기

사용자가 블로그에 들어오면 가장 먼저 보고 싶은 것:
- "어떤 게시글들이 있나?"
- 게시글 목록을 보여줘야 해요!

### 어떻게 만들까요?

게시글 목록을 보여주려면:
1. **데이터베이스에서 게시글들을 가져와야 해요** → Repository 필요
2. **사용자 요청을 받아서 처리해야 해요** → Controller 필요
3. **화면을 만들어야 해요** → 템플릿 필요

하나씩 만들어봅시다!

---

## 1단계: Repository 만들기

### 왜 Repository가 필요한가요?

게시글 목록을 보여주려면:
- 데이터베이스에 저장된 게시글들을 가져와야 해요
- 그런데 데이터베이스는 Java가 아니라 SQL이라는 언어를 써요
- Java에서 SQL을 직접 쓰기 어려워요

**해결책: Repository!**
- Repository는 "데이터베이스와 소통하는 전문가"예요
- Java 코드로 "게시글 가져와!"라고 하면
- Repository가 SQL로 변환해서 데이터베이스에 물어봐요
- 그리고 결과를 Java 객체로 바꿔서 돌려줘요

### Repository 클래스를 만들어봅시다

**파일 위치**: `src/main/java/org/example/demo_ssr_v1_1/board/BoardPersistRepository.java`

파일을 만들고 첫 줄을 써봅시다:

```java
package org.example.demo_ssr_v1_1.board;
```

**이게 뭔가요?**
- 파일 위치를 알려주는 거예요 (목표 1에서 배웠죠!)

### 클래스를 선언해봅시다

```java
public class BoardPersistRepository {
    
}
```

**이게 뭔가요?**
- `BoardPersistRepository`: 클래스 이름
- `Persist`: 저장하다, 지속하다
- **의미**: "게시글을 저장하고 가져오는 저장소"

### Spring이 이 클래스를 알아야 해요

Spring이 이 클래스를 찾아서 사용할 수 있게 해야 해요.
왜냐하면 나중에 Controller에서 이 Repository를 사용할 거거든요!

```java
@Repository
public class BoardPersistRepository {
    
}
```

**`@Repository`가 뭔가요?**
- `Repository`: 저장소
- **의미**: "이 클래스는 데이터베이스 작업을 하는 저장소예요"
- **왜 필요한가요?** Spring이 이 클래스를 찾아서 등록해줘요
- **결과**: 다른 곳에서 이 클래스를 사용할 수 있게 됩니다!

### 데이터베이스와 소통하는 도구가 필요해요

데이터베이스에서 데이터를 가져오려면 특별한 도구가 필요해요.
그 도구가 바로 **EntityManager**예요!

```java
private final EntityManager entityManager;
```

**이게 뭔가요?**
- `private final`: 이 클래스 안에서만 사용하고, 한 번 할당되면 변경 불가
- `EntityManager`: 데이터베이스와 소통하는 도구
- **왜 필요한가요?** 데이터를 가져오고, 저장하고, 수정하고, 삭제하는 데 필요해요

**그런데 이걸 어떻게 만들까요?**
- 직접 `new EntityManager()` 할 수도 있지만...
- Spring이 자동으로 만들어서 넣어줄 수 있어요!
- 그게 바로 **DI (Dependency Injection)**이에요!

### Spring이 자동으로 넣어주게 하려면?

생성자를 만들어야 해요:

```java
@RequiredArgsConstructor
public class BoardPersistRepository {
    private final EntityManager entityManager;
}
```

**`@RequiredArgsConstructor`가 뭔가요?**
- `Required`: 필수인
- `ArgsConstructor`: 생성자
- **의미**: "final 필드에 대한 생성자를 자동으로 만들어줘"
- **결과**: 
  ```java
  public BoardPersistRepository(EntityManager entityManager) {
      this.entityManager = entityManager;
  }
  ```
  이 생성자가 자동으로 만들어집니다!

**왜 이렇게 하나요?**
- Spring이 이 생성자를 보고 "아, EntityManager가 필요하구나!"라고 알아채요
- 그리고 자동으로 EntityManager 객체를 만들어서 넣어줘요
- 개발자가 직접 만들 필요가 없어요!

### 필요한 import 추가하기

```java
package org.example.demo_ssr_v1_1.board;

import jakarta.persistence.EntityManager;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Repository;

@RequiredArgsConstructor
@Repository
public class BoardPersistRepository {
    private final EntityManager entityManager;
}
```

**각 import가 뭔가요?**

1. **`import jakarta.persistence.EntityManager;`**
   - `EntityManager`: 데이터베이스와 소통하는 도구
   - **왜 필요한가요?** EntityManager를 사용하려면 필요해요

2. **`import lombok.RequiredArgsConstructor;`**
   - `RequiredArgsConstructor`: 생성자 자동 생성 기능
   - **왜 필요한가요?** `@RequiredArgsConstructor`를 사용하려면 필요해요

3. **`import org.springframework.stereotype.Repository;`**
   - `Repository`: Spring의 저장소 어노테이션
   - **왜 필요한가요?** `@Repository`를 사용하려면 필요해요

### 게시글을 모두 가져오는 메서드 만들기

이제 진짜로 데이터베이스에서 게시글들을 가져오는 메서드를 만들어봅시다!

```java
public List<Board> findAll() {
    
}
```

**이게 뭔가요?**
- `public`: 누구나 사용할 수 있어요
- `List<Board>`: Board 객체들을 담은 리스트를 반환
  - **List가 뭔가요?** 여러 개를 담을 수 있는 그릇이에요 (배열과 비슷해요)
  - **<Board>가 뭔가요?** Board 객체만 담을 수 있다는 뜻이에요
- `findAll`: "모든 것을 찾아라"
- **왜 List를 반환하나요?** 게시글이 여러 개일 수 있으니까요!

### 데이터베이스에 질문하기

데이터베이스에 "모든 게시글을 가져와줘!"라고 물어봐야 해요.

```java
public List<Board> findAll() {
    return entityManager
            .createQuery("SELECT b FROM Board b ORDER By b.createdAt DESC")
            .getResultList();
}
```

**이게 뭔가요?**

1. **`entityManager.createQuery(...)`**
   - `createQuery`: 쿼리(질문)를 만들어요
   - **쿼리가 뭔가요?** 데이터베이스에 물어보는 질문이에요

2. **`"SELECT b FROM Board b"`**
   - `SELECT`: 선택하다, 가져오다
   - `FROM Board`: Board 엔티티에서
   - `b`: Board의 별칭(별명)
   - **의미**: "Board 엔티티에서 모든 데이터를 가져와줘"
   - **왜 이렇게 쓰나요?** 이것은 JPQL이라는 언어예요 (SQL과 비슷하지만 Java용)

3. **`ORDER By b.createdAt DESC`**
   - `ORDER By`: 정렬하다
   - `b.createdAt`: 작성 시간
   - `DESC`: 내림차순 (큰 것부터 작은 것 순서)
   - **의미**: "작성 시간 기준으로 최신순으로 정렬해줘"
   - **왜 필요한가요?** 최신 게시글이 위에 오게 하려고요!

4. **`.getResultList()`**
   - `getResultList`: 결과를 리스트로 가져와요
   - **결과**: `List<Board>` 형태로 반환됩니다!

### List를 사용하려면 import가 필요해요

```java
import java.util.List;
```

**왜 필요한가요?** `List`를 사용하려면 필요해요!

### 완성된 Repository 코드

```java
package org.example.demo_ssr_v1_1.board;

import jakarta.persistence.EntityManager;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Repository;
import java.util.List;

@RequiredArgsConstructor
@Repository
public class BoardPersistRepository {
    
    private final EntityManager entityManager;
    
    public List<Board> findAll() {
        return entityManager
                .createQuery("SELECT b FROM Board b ORDER By b.createdAt DESC")
                .getResultList();
    }
}
```

좋아요! Repository가 완성되었습니다!

---

## 2단계: Controller 만들기

### 왜 Controller가 필요한가요?

사용자가 브라우저에서 `http://localhost:8080/board/list`에 접속하면:
- 브라우저가 서버에 "게시글 목록 보여줘!"라고 요청해요
- 그런데 서버는 "누가 이 요청을 처리할까?"를 알아야 해요

**해결책: Controller!**
- Controller는 "사용자 요청을 받아서 처리하는 전문가"예요
- "게시글 목록 보여줘!" 요청이 오면
- Repository에서 데이터를 가져와서
- 화면에 전달해줘요

### Controller 클래스를 만들어봅시다

**파일 위치**: `src/main/java/org/example/demo_ssr_v1_1/board/BoardController.java`

파일을 만들고 첫 줄을 써봅시다:

```java
package org.example.demo_ssr_v1_1.board;
```

### 클래스를 선언해봅시다

```java
public class BoardController {
    
}
```

**이게 뭔가요?**
- `BoardController`: 클래스 이름
- `Controller`: 컨트롤러 (요청을 처리하는 것)
- **의미**: "게시글 관련 요청을 처리하는 컨트롤러"

### Spring이 이 클래스를 알아야 해요

```java
@Controller
public class BoardController {
    
}
```

**`@Controller`가 뭔가요?**
- `Controller`: 컨트롤러
- **의미**: "이 클래스가 웹 요청을 처리하는 컨트롤러예요"
- **왜 필요한가요?** Spring이 이 클래스를 찾아서 등록해줘요
- **결과**: 사용자가 요청하면 이 클래스가 처리합니다!

### Repository가 필요해요

게시글 목록을 보여주려면 Repository에서 데이터를 가져와야 해요.
그래서 Repository를 사용할 수 있어야 해요!

```java
private final BoardPersistRepository repository;
```

**이게 뭔가요?**
- `repository`: Repository를 저장하는 변수
- **왜 필요한가요?** 데이터베이스에서 게시글을 가져오려면 Repository가 필요해요

**그런데 이것도 Spring이 자동으로 넣어주면 좋겠어요!**

```java
@RequiredArgsConstructor
@Controller
public class BoardController {
    private final BoardPersistRepository repository;
}
```

**`@RequiredArgsConstructor`가 뭔가요?**
- Repository에서 배웠죠? 같은 거예요!
- final 필드에 대한 생성자를 자동으로 만들어줘요
- Spring이 이 생성자를 보고 Repository를 자동으로 넣어줘요!

### 필요한 import 추가하기

```java
package org.example.demo_ssr_v1_1.board;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Controller;
import java.util.List;

@RequiredArgsConstructor
@Controller
public class BoardController {
    private final BoardPersistRepository repository;
}
```

**각 import가 뭔가요?**

1. **`import lombok.RequiredArgsConstructor;`**
   - 생성자 자동 생성 기능
   - **왜 필요한가요?** `@RequiredArgsConstructor`를 사용하려면 필요해요

2. **`import org.springframework.stereotype.Controller;`**
   - Controller 어노테이션
   - **왜 필요한가요?** `@Controller`를 사용하려면 필요해요

3. **`import java.util.List;`**
   - List 타입
   - **왜 필요한가요?** 나중에 List를 사용할 거예요

### 게시글 목록을 보여주는 메서드 만들기

이제 진짜로 사용자 요청을 처리하는 메서드를 만들어봅시다!

**사용자가 `/board/list`에 접속하면 이 메서드가 실행되어야 해요.**

```java
@GetMapping("/board/list")
public String boardList() {
    
}
```

**이게 뭔가요?**

1. **`@GetMapping("/board/list")`**
   - `GetMapping`: GET 방식 요청을 처리
   - **GET 방식이 뭔가요?** 브라우저 주소창에 입력하거나 링크를 클릭할 때 사용해요
   - `"/board/list"`: 이 경로로 요청이 오면
   - **의미**: "GET 방식으로 `/board/list` 요청이 오면 이 메서드를 실행해줘"
   - **왜 필요한가요?** Spring이 어떤 요청을 어떤 메서드가 처리할지 알아야 해요!

2. **`public String boardList()`**
   - `boardList`: 메서드 이름
   - `String`: 문자열을 반환
   - **왜 String을 반환하나요?** 나중에 설명할게요!

### Repository에서 데이터 가져오기

게시글 목록을 보여주려면 데이터가 필요해요.
Repository에서 가져와봅시다!

```java
@GetMapping("/board/list")
public String boardList() {
    List<Board> boardList = repository.findAll();
}
```

**이게 뭔가요?**
- `repository.findAll()`: Repository의 findAll 메서드 호출
- **동작 과정**:
  1. Repository가 데이터베이스에 가서 모든 게시글 조회
  2. `List<Board>` 형태로 반환
  3. `boardList` 변수에 저장
- **결과**: `boardList`에 모든 게시글이 들어있어요!

### 화면에 데이터를 전달해야 해요

데이터를 가져왔지만, 화면(템플릿)에 전달해야 해요.
그래야 화면에서 게시글들을 보여줄 수 있어요!

**그런데 어떻게 전달하나요?**

**Model**이라는 도구를 사용해요!

```java
@GetMapping("/board/list")
public String boardList(Model model) {
    List<Board> boardList = repository.findAll();
}
```

**`Model model`이 뭔가요?**
- `Model`: 화면에 데이터를 전달하는 도구
- **왜 필요한가요?** Controller에서 템플릿으로 데이터를 전달하기 위해 필요해요
- **Spring이 자동으로 만들어줘요!** 개발자가 직접 만들 필요 없어요!

**파라미터가 왜 필요한가요?**
- 메서드가 Model을 사용하려면 받아와야 해요
- Spring이 자동으로 Model 객체를 만들어서 넣어줘요
- 우리는 이 Model에 데이터를 넣기만 하면 됩니다!

### Model에 데이터 넣기

```java
@GetMapping("/board/list")
public String boardList(Model model) {
    List<Board> boardList = repository.findAll();
    model.addAttribute("boardList", boardList);
}
```

**`model.addAttribute("boardList", boardList)`가 뭔가요?**
- `addAttribute`: 속성을 추가하다
- `"boardList"`: 템플릿에서 사용할 이름 (키)
- `boardList`: 실제 데이터 (값)
- **의미**: "Model에 'boardList'라는 이름으로 게시글 목록을 넣어줘"
- **왜 필요한가요?** 템플릿에서 `{{#boardList}}`로 이 데이터를 사용할 수 있게 해줘요!

### 어떤 화면을 보여줄지 알려주기

데이터를 전달했으니, 이제 어떤 화면을 보여줄지 알려줘야 해요.

```java
@GetMapping("/board/list")
public String boardList(Model model) {
    List<Board> boardList = repository.findAll();
    model.addAttribute("boardList", boardList);
    return "board/list";
}
```

**`return "board/list"`가 뭔가요?**
- `return`: 반환하다
- `"board/list"`: 템플릿 파일 경로
- **의미**: "`templates/board/list.mustache` 파일을 렌더링해줘"
- **왜 String을 반환하나요?** Spring이 이 문자열을 템플릿 파일 경로로 인식해요
- **동작**: Spring이 `templates/board/list.mustache` 파일을 찾아서 HTML로 변환해서 브라우저에 보냅니다!

**void를 쓰면 안 되나요?**
- void를 쓰면 Spring이 어떤 페이지를 보여줄지 모라요
- 반드시 템플릿 경로를 반환해야 해요!

### Model을 사용하려면 import가 필요해요

```java
import org.springframework.ui.Model;
```

**왜 필요한가요?** `Model`을 사용하려면 필요해요!

### 완성된 Controller 코드

```java
package org.example.demo_ssr_v1_1.board;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import java.util.List;

@RequiredArgsConstructor
@Controller
public class BoardController {
    
    private final BoardPersistRepository repository;
    
    @GetMapping("/board/list")
    public String boardList(Model model) {
        List<Board> boardList = repository.findAll();
        model.addAttribute("boardList", boardList);
        return "board/list";
    }
}
```

좋아요! Controller가 완성되었습니다!

---

## 3단계: 템플릿 만들기

### Mustache가 뭔가요?

**Mustache**는 템플릿 엔진입니다!

**템플릿 엔진이 뭔가요?**
- HTML에 변수나 반복문을 넣어서 동적으로 페이지를 만드는 도구
- 예: 게시글이 3개면 카드 3개, 10개면 카드 10개가 자동으로 만들어져요!

**왜 Mustache를 쓰나요?**
- 서버에서 HTML을 완성해서 브라우저에 보내는 방식 (SSR)
- Java 객체의 데이터를 HTML로 변환해줘요
- 문법이 간단하고 쉬워요!

### Mustache 기본 문법

#### 1. 변수 출력하기

```mustache
{{변수이름}}
```

**이게 뭔가요?**
- Controller에서 전달한 데이터를 출력해요
- **예시**:
  ```java
  // Controller에서
  model.addAttribute("title", "안녕하세요");
  ```
  ```mustache
  <!-- 템플릿에서 -->
  <h1>{{title}}</h1>
  ```
  **결과**: `<h1>안녕하세요</h1>` 출력

**중첩된 객체는?**
```mustache
{{객체.필드}}
```
- **예시**: `{{board.title}}` → board 객체의 title 필드 출력

#### 2. 반복문 (리스트)

```mustache
{{#리스트이름}}
    <!-- 반복할 내용 -->
{{/리스트이름}}
```

**이게 뭔가요?**
- 리스트의 각 항목에 대해 반복해요
- **예시**:
  ```java
  // Controller에서
  List<Board> boardList = ...;
  model.addAttribute("boardList", boardList);
  ```
  ```mustache
  {{#boardList}}
      <div>{{title}}</div>
  {{/boardList}}
  ```
  **동작**:
  - boardList에 게시글이 3개 있다면
  - `<div>{{title}}</div>`가 3번 실행됨
  - 각 게시글마다 div가 하나씩 생성됨!

**반복문 안에서 현재 항목 사용하기**
```mustache
{{#boardList}}
    <div>{{title}}</div>  <!-- 현재 게시글의 제목 -->
    <div>{{content}}</div>  <!-- 현재 게시글의 내용 -->
{{/boardList}}
```

#### 3. 조건문 (있으면 보여주기)

```mustache
{{#변수이름}}
    <!-- 변수가 있으면(true면) 보여줌 -->
{{/변수이름}}
```

**이게 뭔가요?**
- 변수가 존재하고 true면 내용을 보여줘요
- **예시**:
  ```mustache
  {{#board}}
      <h1>{{board.title}}</h1>
  {{/board}}
  ```
  - board가 있으면 제목을 보여줌
  - board가 null이거나 false면 아무것도 안 보여줌

#### 4. 반대 조건 (없으면 보여주기)

```mustache
{{^변수이름}}
    <!-- 변수가 없으면(false면) 보여줌 -->
{{/변수이름}}
```

**이게 뭔가요?**
- 변수가 없거나 false면 내용을 보여줘요
- **예시**:
  ```mustache
  {{^boardList}}
      <p>게시글이 없습니다.</p>
  {{/boardList}}
  ```
  - boardList가 없거나 비어있으면 "게시글이 없습니다." 보여줌

#### 5. 부분 템플릿 (Partial) - 파일 불러오기

```mustache
{{> 파일경로}}
```

**이게 뭔가요?**
- 다른 템플릿 파일을 불러와서 삽입해요
- **예시**:
  ```mustache
  {{> layout/header}}
  ```
  - `templates/layout/header.mustache` 파일을 불러와서 여기에 넣어줘요
  - **왜 필요한가요?** 공통 헤더, 푸터를 재사용하기 위해요!

#### 6. HTML 이스케이프 (특수문자 그대로 출력)

```mustache
{{{변수이름}}}
```

**이게 뭔가요?**
- HTML 태그를 그대로 출력해요 (보안상 주의!)
- **예시**:
  ```mustache
  {{content}}     <!-- HTML 태그가 이스케이프됨 -->
  {{{content}}}   <!-- HTML 태그가 그대로 출력됨 -->
  ```

#### 7. 주석

```mustache
{{! 주석 내용 }}
```

**이게 뭔가요?**
- 주석이에요 (화면에 안 보임)

### Mustache 문법 정리표

| 문법 | 의미 | 예시 |
|------|------|------|
| `{{변수}}` | 변수 출력 | `{{title}}` |
| `{{#리스트}}...{{/리스트}}` | 반복문 | `{{#boardList}}...{{/boardList}}` |
| `{{#변수}}...{{/변수}}` | 조건문 (있으면) | `{{#board}}...{{/board}}` |
| `{{^변수}}...{{/변수}}` | 조건문 (없으면) | `{{^boardList}}...{{/boardList}}` |
| `{{> 파일경로}}` | 부분 템플릿 | `{{> layout/header}}` |
| `{{{변수}}}` | HTML 그대로 출력 | `{{{content}}}` |
| `{{! 주석}}` | 주석 | `{{! 이것은 주석}}` |

### 왜 템플릿이 필요한가요?

데이터를 가져왔지만, 화면이 없으면 사용자가 볼 수 없어요!
화면을 만들어야 해요.

**템플릿이 뭔가요?**
- HTML에 변수를 넣어서 동적으로 페이지를 만드는 것
- 예: 게시글이 3개면 카드 3개, 10개면 카드 10개가 자동으로 만들어져요!

### 템플릿 파일을 만들어봅시다

**파일 위치**: `src/main/resources/templates/board/list.mustache`

**왜 이 위치인가요?**
- Spring은 `templates` 폴더 안의 파일을 템플릿으로 인식해요
- `board/list` → `templates/board/list.mustache` 파일을 찾아요

### 헤더를 불러와봅시다

모든 페이지에 공통으로 들어가는 헤더가 있어요.
그걸 불러와봅시다!

```mustache
{{> layout/header}}
```

**이게 뭔가요?**
- `{{> ... }}`: 부분 템플릿(Partial)을 불러오는 문법
- `layout/header`: `templates/layout/header.mustache` 파일
- **의미**: "헤더 파일을 불러와서 여기에 넣어줘"
- **왜 필요한가요?** 모든 페이지에 공통 헤더를 재사용하기 위해요!

### 게시글 목록을 보여주기

이제 진짜로 게시글 목록을 보여줘봅시다!

```mustache
{{#boardList}}
    <div class="card mb-3">
        <div class="card-body">
            <h4 class="card-title mb-3">{{title}}</h4>
            <a href="/board/{{id}}" class="btn btn-primary">상세보기</a>
        </div>
    </div>
{{/boardList}}
```

**이게 뭔가요?**

1. **`{{#boardList}} ... {{/boardList}}`**
   - `{{#boardList}}`: 반복문 시작
   - `{{/boardList}}`: 반복문 끝
   - **의미**: "boardList의 각 항목에 대해 반복해줘"
   - **동작**:
     - Controller에서 `model.addAttribute("boardList", boardList)`로 전달
     - boardList에 게시글이 3개 있다면
     - 중괄호 안의 코드가 3번 실행됨
     - 각 게시글마다 카드가 하나씩 생성됨!

2. **`{{title}}`**
   - 현재 반복 중인 게시글의 제목을 출력
   - **예시**: 
     - 첫 번째 게시글: "안녕하세요" 출력
     - 두 번째 게시글: "오늘 날씨 좋네요" 출력

3. **`{{id}}`**
   - 현재 반복 중인 게시글의 ID를 출력
   - **예시**: `/board/1`, `/board/2` 등
   - **왜 필요한가요?** 상세보기 링크에 사용해요!

### 푸터를 불러와봅시다

```mustache
{{> layout/footer}}
```

**이게 뭔가요?**
- 헤더와 마찬가지로 공통 푸터를 불러옵니다!

### 완성된 템플릿 코드

```mustache
{{> layout/header}}

<div class="container p-5">
    {{#boardList}}
    <div class="card mb-3">
        <div class="card-body">
            <h4 class="card-title mb-3">{{title}}</h4>
            <a href="/board/{{id}}" class="btn btn-primary">상세보기</a>
        </div>
    </div>
    {{/boardList}}
</div>

{{> layout/footer}}
```

좋아요! 템플릿이 완성되었습니다!

---

## 🎬 전체 동작 흐름

이제 모든 것이 준비되었어요! 어떻게 동작하는지 봅시다:

1. **사용자**: 브라우저에서 `http://localhost:8080/board/list` 접속
2. **브라우저**: GET 요청을 서버로 전송
3. **Spring**: `@GetMapping("/board/list")`를 찾아서 `boardList()` 메서드 실행
4. **Controller**: 
   - `repository.findAll()` 호출
   - Repository가 데이터베이스에서 모든 게시글 조회
   - `model.addAttribute("boardList", boardList)`로 데이터 전달
   - `return "board/list"`
5. **Spring**: `templates/board/list.mustache` 파일을 찾음
6. **Mustache**: 
   - `{{#boardList}}`로 반복문 실행
   - 각 게시글의 제목, 링크 등을 HTML로 생성
7. **서버**: 완성된 HTML을 브라우저로 전송
8. **브라우저**: HTML을 화면에 표시

완벽해요! 🎉

---

## 🎉 목표 2 완료!

이제 게시글 목록을 볼 수 있습니다!

### 배운 것들

1. **Repository**: 데이터베이스와 소통하는 클래스
2. **EntityManager**: 데이터베이스 작업을 하는 도구
3. **Controller**: 사용자 요청을 처리하는 클래스
4. **Model**: 화면에 데이터를 전달하는 도구
5. **템플릿**: 동적으로 HTML을 생성하는 파일
6. **Mustache 문법**: `{{#}}`, `{{}}`, `{{>}}` 등

### 핵심 정리

**왜 Repository가 필요한가요?**
- 데이터베이스에서 데이터를 가져오려면 필요해요
- Java와 데이터베이스 사이의 다리 역할을 해요

**왜 Controller가 필요한가요?**
- 사용자 요청을 받아서 처리하려면 필요해요
- Repository에서 데이터를 가져와서 화면에 전달해요

**왜 Model이 필요한가요?**
- Controller에서 템플릿으로 데이터를 전달하기 위해 필요해요
- Model 없이는 템플릿에 데이터를 보낼 수 없어요

**왜 String을 반환하나요?**
- 템플릿 파일 경로를 반환해야 해요
- Spring이 이 경로를 보고 템플릿을 찾아서 렌더링해요

### 다음 수업에서는?

게시글을 작성하는 기능을 만들어봅시다!
- 사용자가 제목, 내용, 작성자를 입력해서
- 데이터베이스에 저장하는 것

다음 수업에서 만나요! 👋

