# Mustache 템플릿 엔진 수업 - 단계별 개발 가이드

## 📚 이 수업을 듣기 전에 알아야 할 것

이 수업은 **정말 처음부터** 설명합니다. 다음을 모르셔도 괜찮습니다:
- 파라미터가 뭔지
- Model이 왜 필요한지
- 왜 String을 반환하는지
- 어노테이션이 뭔지

하지만 다음은 알고 계셔야 합니다:
- Java 기본 문법 (클래스, 메서드 개념)
- HTML 기본 문법

---

## 🎯 수업 목표

이 수업을 끝내면 다음을 만들 수 있습니다:
1. ✅ 게시글 목록 보기
2. ✅ 게시글 작성하기
3. ✅ 게시글 상세보기
4. ✅ 게시글 수정하기
5. ✅ 게시글 삭제하기

---

## 📖 목차

1. [프로젝트 시작하기](#1-프로젝트-시작하기)
2. [목표 1: Board 엔티티 만들기](#목표-1-board-엔티티-만들기)
3. [목표 2: 게시글 목록 보기](#목표-2-게시글-목록-보기)
4. [목표 3: 게시글 작성하기](#목표-3-게시글-작성하기)
5. [목표 4: 게시글 상세보기](#목표-4-게시글-상세보기)
6. [목표 5: 게시글 수정하기](#목표-5-게시글-수정하기)
7. [목표 6: 게시글 삭제하기](#목표-6-게시글-삭제하기)

---

## 1. 프로젝트 시작하기

### 1-1. 프로젝트가 이미 준비되어 있다면

이미 Spring Boot 프로젝트가 준비되어 있습니다. 다음 파일들이 있는지 확인하세요:
- `build.gradle`: 프로젝트 설정 파일
- `src/main/java/.../DemoSsrV11Application.java`: 프로그램 시작점

### 1-2. 프로젝트 구조 이해하기

```
src/main/
├── java/              # Java 소스 코드
└── resources/
    ├── templates/     # Mustache 템플릿 파일 (HTML)
    └── application.yml # 설정 파일
```

**왜 이렇게 나뉘어 있나요?**
- `java/`: 서버 로직 (컨트롤러, 엔티티 등)
- `templates/`: 화면 (HTML 파일들)
- 서버 로직과 화면을 분리해서 관리하기 쉽게!

---

## 목표 1: Board 엔티티 만들기

### 🎯 목표
게시글 데이터를 저장할 수 있는 클래스를 만듭니다.

### 🤔 왜 필요한가요?

게시글에는 어떤 정보가 필요할까요?
- 제목
- 내용
- 작성자
- 작성 시간
- 고유 번호 (ID)

이런 정보를 담을 수 있는 클래스가 필요합니다. 이 클래스를 **Entity(엔티티)**라고 합니다.

### 📝 단계 1: Board 클래스 만들기

**파일 위치**: `src/main/java/org/example/demo_ssr_v1_1/board/Board.java`

```java
package org.example.demo_ssr_v1_1.board;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import java.sql.Timestamp;

@Data
@NoArgsConstructor
@Table(name = "board_tb")
@Entity
public class Board {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String title;
    private String content;
    private String username;
    
    @CreationTimestamp
    private Timestamp createdAt;
}
```

### 🔍 코드 하나하나 설명

#### 1. `package org.example.demo_ssr_v1_1.board;`
- **의미**: 이 파일이 어느 폴더에 있는지 알려줌
- **왜 필요한가?**: Java는 파일 위치를 정확히 알아야 함

#### 2. `import` 문들
- **의미**: 다른 곳에 있는 클래스들을 가져옴
- **예시**: `import lombok.Data;` → Lombok의 Data 클래스를 사용하겠다

#### 3. `@Data`
- **의미**: 자동으로 getter, setter 메서드를 만들어줌
- **왜 필요한가?**: 
  - `getId()`, `setId()`, `getTitle()`, `setTitle()` 같은 메서드를 자동 생성
  - 수동으로 만들면 코드가 길어짐
- **예시**: 
  ```java
  Board board = new Board();
  board.setTitle("안녕하세요");  // @Data가 자동으로 만들어줌
  String title = board.getTitle();  // @Data가 자동으로 만들어줌
  ```

#### 4. `@NoArgsConstructor`
- **의미**: 매개변수 없는 생성자를 자동으로 만들어줌
- **왜 필요한가?**: JPA(데이터베이스 도구)가 객체를 만들 때 필요
- **예시**: `new Board()` ← 이렇게 만들 수 있게 해줌

#### 5. `@Table(name = "board_tb")`
- **의미**: 데이터베이스의 `board_tb` 테이블과 연결한다
- **왜 필요한가?**: 
  - 클래스 이름은 `Board`인데
  - 데이터베이스 테이블 이름은 `board_tb`라서
  - 둘을 연결해줘야 함

#### 6. `@Entity`
- **의미**: "이 클래스는 데이터베이스 테이블과 연결되는 엔티티다"
- **왜 필요한가?**: JPA가 이 클래스를 데이터베이스와 연결해줌

#### 7. `public class Board`
- **의미**: Board라는 이름의 클래스를 만듦
- **public**: 다른 곳에서도 사용할 수 있게 함

#### 8. `@Id`
- **의미**: "이 필드가 기본 키(Primary Key)다"
- **왜 필요한가?**: 각 게시글을 구분하는 고유 번호가 필요
- **예시**: 게시글 1번, 게시글 2번... 이렇게 구분

#### 9. `@GeneratedValue(strategy = GenerationType.IDENTITY)`
- **의미**: "이 값은 자동으로 생성해줘"
- **왜 필요한가?**: 새 게시글을 만들 때마다 1, 2, 3... 자동으로 번호 부여
- **예시**: 
  - 첫 번째 게시글: id = 1
  - 두 번째 게시글: id = 2
  - 개발자가 직접 번호를 지정할 필요 없음!

#### 10. `private Long id;`
- **의미**: 게시글 고유 번호를 저장하는 변수
- **Long**: 큰 정수를 저장하는 타입 (1, 2, 3...)
- **private**: 이 클래스 안에서만 직접 접근 가능 (보안)

#### 11. `private String title;`
- **의미**: 게시글 제목을 저장하는 변수
- **String**: 텍스트를 저장하는 타입
- **예시**: "안녕하세요", "오늘 날씨 좋네요" 등

#### 12. `@CreationTimestamp`
- **의미**: "데이터가 생성될 때 자동으로 현재 시간을 저장해줘"
- **왜 필요한가?**: 게시글 작성 시간을 자동으로 기록
- **예시**: 2024-01-15 10:30:00 자동 저장

### ✅ 목표 1 완료!

이제 게시글 데이터를 담을 수 있는 클래스가 완성되었습니다!

---

## 목표 2: 게시글 목록 보기

### 🎯 목표
데이터베이스에 있는 모든 게시글을 화면에 보여줍니다.

### 🤔 왜 필요한가요?

사용자가 블로그에 들어오면 가장 먼저 보고 싶은 것:
- "어떤 게시글들이 있나?"
- 게시글 목록을 보여줘야 합니다!

### 📝 개발 순서

1. **Repository 만들기** (데이터베이스에서 데이터 가져오기)
2. **Controller 만들기** (요청 받아서 처리하기)
3. **템플릿 만들기** (화면 만들기)

### 📝 단계 1: Repository 만들기

**왜 Repository가 필요한가요?**
- 데이터베이스에서 데이터를 가져오는 일을 담당
- Controller는 "데이터 가져와!"라고만 하면
- Repository가 실제로 데이터베이스에 가서 가져옴

**파일 위치**: `src/main/java/org/example/demo_ssr_v1_1/board/BoardPersistRepository.java`

```java
package org.example.demo_ssr_v1_1.board;

import jakarta.persistence.EntityManager;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Repository;
import java.util.List;

@RequiredArgsConstructor
@Repository
public class BoardPersistRepository {
    
    private final EntityManager entityManager;
    
    public List<Board> findAll() {
        return entityManager
                .createQuery("SELECT b FROM Board b ORDER By b.createdAt DESC")
                .getResultList();
    }
}
```

### 🔍 코드 하나하나 설명

#### 1. `@Repository`
- **의미**: "이 클래스는 데이터베이스 작업을 하는 저장소다"
- **왜 필요한가?**: Spring이 이 클래스를 찾아서 등록해줌
- **결과**: 다른 곳에서 이 클래스를 사용할 수 있게 됨

#### 2. `@RequiredArgsConstructor`
- **의미**: "final 필드에 대한 생성자를 자동으로 만들어줘"
- **왜 필요한가?**: 
  - `private final EntityManager entityManager;` 이 필드가 있으면
  - 자동으로 생성자를 만들어줌
  - Spring이 이 생성자를 통해 객체를 주입해줌 (DI)

#### 3. `private final EntityManager entityManager;`
- **의미**: 데이터베이스와 소통하는 도구
- **왜 필요한가?**: 데이터를 가져오고, 저장하고, 수정하고, 삭제하는 데 필요
- **final**: 한 번 할당되면 변경 불가 (안전성)
- **Spring이 자동으로 넣어줌**: 개발자가 `new EntityManager()` 할 필요 없음!

#### 4. `public List<Board> findAll()`
- **의미**: 모든 게시글을 가져오는 메서드
- **List<Board>**: Board 객체들을 담은 리스트를 반환
  - **List**: 여러 개를 담을 수 있는 그릇 (배열과 비슷)
  - **<Board>**: Board 객체만 담을 수 있다는 뜻
- **왜 List를 반환하나?**: 게시글이 여러 개일 수 있으니까!

#### 5. `entityManager.createQuery(...)`
- **의미**: 데이터베이스에 쿼리(질문)를 보냄
- **"SELECT b FROM Board b"**: 
  - Board 엔티티에서 모든 데이터를 가져옴
  - `b`는 Board의 별칭(별명)
- **ORDER By b.createdAt DESC**: 
  - 작성일 기준으로 내림차순 정렬
  - DESC = 내림차순 (최신순)
  - 최신 게시글이 위에 오게!

#### 6. `.getResultList()`
- **의미**: 쿼리 결과를 리스트로 가져옴
- **결과**: `List<Board>` 형태로 반환

### 📝 단계 2: Controller 만들기

**왜 Controller가 필요한가요?**
- 사용자의 요청을 받아서 처리
- "게시글 목록 보여줘!" 요청이 오면
- Repository에서 데이터를 가져와서
- 화면에 전달

**파일 위치**: `src/main/java/org/example/demo_ssr_v1_1/board/BoardController.java`

```java
package org.example.demo_ssr_v1_1.board;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import java.util.List;

@RequiredArgsConstructor
@Controller
public class BoardController {
    
    private final BoardPersistRepository repository;
    
    @GetMapping({"/board/list", "/"})
    public String boardList(Model model) {
        List<Board> boardList = repository.findAll();
        model.addAttribute("boardList", boardList);
        return "board/list";
    }
}
```

### 🔍 코드 하나하나 설명

#### 1. `@Controller`
- **의미**: "이 클래스가 웹 요청을 처리하는 컨트롤러다"
- **왜 필요한가?**: Spring이 이 클래스를 찾아서 등록
- **결과**: 사용자가 웹 브라우저에서 요청하면 이 클래스가 처리

#### 2. `@RequiredArgsConstructor`
- **의미**: final 필드에 대한 생성자 자동 생성
- **결과**: `private final BoardPersistRepository repository;`를 자동으로 주입받을 수 있음

#### 3. `private final BoardPersistRepository repository;`
- **의미**: Repository를 사용하기 위한 변수
- **왜 필요한가?**: 데이터베이스에서 데이터를 가져오려면 Repository가 필요
- **Spring이 자동으로 넣어줌**: 개발자가 직접 만들 필요 없음!

#### 4. `@GetMapping({"/board/list", "/"})`
- **의미**: "GET 방식으로 `/board/list` 또는 `/` 요청이 오면 이 메서드를 실행해"
- **GET 방식**: 브라우저 주소창에 입력하거나 링크를 클릭할 때
- **{"/board/list", "/"}**: 두 경로 모두 처리
  - `/board/list` → 게시글 목록
  - `/` (루트) → 게시글 목록 (메인 페이지)

#### 5. `public String boardList(Model model)`
- **의미**: 게시글 목록을 보여주는 메서드
- **왜 String을 반환하나?**: 
  - 템플릿 파일 경로를 반환해야 함
  - `"board/list"` → Spring이 `templates/board/list.mustache` 파일을 찾음
  - 이 파일을 렌더링해서 HTML로 만들어서 브라우저에 보냄
- **Model model이 왜 필요한가?**
  - 화면(템플릿)에 데이터를 전달하기 위해 필요
  - Repository에서 가져온 데이터를 템플릿에 넘겨줘야 함
  - 템플릿에서 `{{boardList}}`로 사용할 수 있게 해줌
- **파라미터가 왜 필요한가?**
  - Spring이 자동으로 Model 객체를 만들어서 넣어줌
  - 우리는 이 Model에 데이터를 넣기만 하면 됨

#### 6. `List<Board> boardList = repository.findAll();`
- **의미**: Repository에서 모든 게시글을 가져옴
- **동작 과정**:
  1. `repository.findAll()` 호출
  2. Repository가 데이터베이스에 가서 모든 게시글 조회
  3. `List<Board>` 형태로 반환
  4. `boardList` 변수에 저장

#### 7. `model.addAttribute("boardList", boardList);`
- **의미**: Model에 데이터를 추가
- **"boardList"**: 템플릿에서 사용할 이름 (키)
- **boardList**: 실제 데이터 (값)
- **왜 필요한가?**: 
  - 템플릿에서 `{{#boardList}}`로 이 데이터를 사용할 수 있게 해줌
  - Model 없이는 템플릿에 데이터를 전달할 수 없음!

#### 8. `return "board/list";`
- **의미**: `templates/board/list.mustache` 파일을 렌더링
- **왜 String을 반환하나?**: 
  - Spring이 이 문자열을 템플릿 파일 경로로 인식
  - `"board/list"` → `templates/board/list.mustache` 찾음
  - 이 파일을 HTML로 변환해서 브라우저에 보냄
- **void를 쓰면 안 되나?**
  - void를 쓰면 Spring이 어떤 페이지를 보여줄지 모름
  - 반드시 템플릿 경로를 반환해야 함

### 📝 단계 3: 템플릿 만들기

**왜 템플릿이 필요한가요?**
- 실제 화면을 보여주기 위해
- 데이터를 HTML로 변환하기 위해

**파일 위치**: `src/main/resources/templates/board/list.mustache`

```mustache
{{> layout/header}}

<div class="container p-5">
    {{#boardList}}
    <div class="card mb-3">
        <div class="card-body">
            <h4 class="card-title mb-3">{{title}}</h4>
            <a href="/board/{{id}}" class="btn btn-primary">상세보기</a>
        </div>
    </div>
    {{/boardList}}
</div>

{{> layout/footer}}
```

### 🔍 코드 하나하나 설명

#### 1. `{{> layout/header}}`
- **의미**: `templates/layout/header.mustache` 파일을 불러와서 삽입
- **왜 필요한가?**: 모든 페이지에 공통으로 들어가는 헤더를 재사용
- **예시**: 네비게이션 바, 로고 등

#### 2. `{{#boardList}} ... {{/boardList}}`
- **의미**: `boardList`의 각 항목에 대해 반복
- **동작 과정**:
  1. Controller에서 `model.addAttribute("boardList", boardList)`로 전달
  2. `boardList`에 게시글이 3개 있다면
  3. 중괄호 안의 코드가 3번 실행됨
  4. 각 게시글마다 카드가 하나씩 생성됨

#### 3. `{{title}}`
- **의미**: 현재 반복 중인 게시글의 제목을 출력
- **예시**: 
  - 첫 번째 게시글: "안녕하세요" 출력
  - 두 번째 게시글: "오늘 날씨 좋네요" 출력

#### 4. `{{id}}`
- **의미**: 현재 반복 중인 게시글의 ID를 출력
- **예시**: `/board/1`, `/board/2` 등
- **왜 필요한가?**: 상세보기 링크에 사용

#### 5. `{{> layout/footer}}`
- **의미**: `templates/layout/footer.mustache` 파일을 불러와서 삽입
- **왜 필요한가?**: 모든 페이지에 공통으로 들어가는 푸터를 재사용

### 🎬 전체 동작 흐름

1. **사용자**: 브라우저에서 `http://localhost:8080/board/list` 접속
2. **브라우저**: GET 요청을 서버로 전송
3. **Spring**: `@GetMapping("/board/list")`를 찾아서 `boardList()` 메서드 실행
4. **Controller**: 
   - `repository.findAll()` 호출
   - Repository가 데이터베이스에서 모든 게시글 조회
   - `model.addAttribute("boardList", boardList)`로 데이터 전달
   - `return "board/list"`
5. **Spring**: `templates/board/list.mustache` 파일을 찾음
6. **Mustache**: 
   - `{{#boardList}}`로 반복문 실행
   - 각 게시글의 제목, 링크 등을 HTML로 생성
7. **서버**: 완성된 HTML을 브라우저로 전송
8. **브라우저**: HTML을 화면에 표시

### ✅ 목표 2 완료!

이제 게시글 목록을 볼 수 있습니다!

---

## 목표 3: 게시글 작성하기

### 🎯 목표
사용자가 게시글을 작성해서 데이터베이스에 저장합니다.

### 🤔 왜 필요한가요?

게시글 목록만 보여주면 안 되죠!
- 사용자가 새 게시글을 작성할 수 있어야 함
- 작성한 게시글이 데이터베이스에 저장되어야 함

### 📝 개발 순서

1. **작성 폼 페이지 만들기** (사용자가 입력할 화면)
2. **저장 기능 만들기** (데이터베이스에 저장)

### 📝 단계 1: 작성 폼 페이지 만들기

**파일 위치**: `src/main/resources/templates/board/save-form.mustache`

```mustache
{{> layout/header}}

<div class="container p-5">
    <div class="card">
        <div class="card-header"><b>글쓰기 화면입니다</b></div>
        <div class="card-body">
            <form action="/board/save" method="post">
                <div class="mb-3">
                    <input type="text" class="form-control" 
                           placeholder="Enter username" name="username">
                </div>
                <div class="mb-3">
                    <input type="text" class="form-control" 
                           placeholder="Enter title" name="title">
                </div>
                <div class="mb-3">
                    <textarea class="form-control" rows="5" 
                              name="content"></textarea>
                </div>
                <button class="btn btn-primary form-control">글쓰기완료</button>
            </form>
        </div>
    </div>
</div>

{{> layout/footer}}
```

### 🔍 코드 하나하나 설명

#### 1. `<form action="/board/save" method="post">`
- **의미**: 폼이 제출되면 `/board/save`로 POST 요청을 보냄
- **action**: 데이터를 보낼 주소
- **method="post"**: POST 방식으로 전송
  - **GET vs POST**:
    - GET: URL에 데이터가 노출됨 (예: `/board/save?title=안녕`)
    - POST: 요청 본문에 데이터가 숨겨짐 (보안상 좋음)
- **왜 POST를 쓰나?**: 데이터를 저장하는 작업이므로 POST 사용

#### 2. `name="username"`
- **의미**: 이 입력 필드의 이름
- **왜 중요한가?**: 
  - 서버에서 이 이름으로 데이터를 받음
  - Controller에서 `SaveDTO`의 `username` 필드와 자동으로 매칭됨
- **예시**: 사용자가 "홍길동" 입력 → 서버에서 `username = "홍길동"`으로 받음

#### 3. `name="title"`, `name="content"`
- **의미**: 제목과 내용 입력 필드
- **동작**: `name` 속성과 DTO 필드명이 같으면 자동으로 매칭

### 📝 단계 2: Controller에 작성 폼 메서드 추가

**Controller에 추가할 코드**:

```java
@GetMapping("/board/save")
public String saveFrom() {
    return "board/save-form";
}
```

### 🔍 코드 하나하나 설명

#### 1. `@GetMapping("/board/save")`
- **의미**: GET 방식으로 `/board/save` 요청이 오면 실행
- **왜 GET인가?**: 단순히 작성 폼 페이지를 보여주는 것이므로 GET

#### 2. `public String saveFrom()`
- **의미**: 작성 폼 페이지를 보여주는 메서드
- **왜 파라미터가 없나?**: 
  - 단순히 페이지만 보여주면 되므로
  - 데이터를 전달할 필요가 없음
  - Model도 필요 없음 (데이터를 보여줄 게 없으니까)
- **왜 String을 반환하나?**: 템플릿 파일 경로를 반환해야 함

#### 3. `return "board/save-form";`
- **의미**: `templates/board/save-form.mustache` 파일을 렌더링

### 📝 단계 3: DTO 만들기

**왜 DTO가 필요한가요?**
- 사용자가 보낸 데이터를 받기 위해
- Entity와 분리해서 관리하기 위해

**파일 위치**: `src/main/java/org/example/demo_ssr_v1_1/board/BoardRequest.java`

```java
package org.example.demo_ssr_v1_1.board;

import lombok.Data;

public class BoardRequest {
    
    @Data
    public static class SaveDTO {
        private String title;
        private String content;
        private String username;
        
        public Board toEntity() {
            return new Board(title, content, username);
        }
    }
}
```

### 🔍 코드 하나하나 설명

#### 1. `public class BoardRequest`
- **의미**: 요청 관련 DTO들을 모아놓은 클래스
- **왜 정적 내부 클래스를 쓰나?**: 관련된 클래스들을 한 곳에 모아서 관리

#### 2. `@Data`
- **의미**: getter, setter 자동 생성
- **결과**: 
  - `getTitle()`, `setTitle()` 등 자동 생성
  - Spring이 폼 데이터를 이 객체에 자동으로 넣어줌

#### 3. `private String title;` 등
- **의미**: 폼에서 보낸 데이터를 저장하는 필드
- **중요**: `name="title"`과 필드명 `title`이 같아야 자동 매칭됨!

#### 4. `public Board toEntity()`
- **의미**: DTO를 Entity로 변환
- **왜 필요한가?**: 
  - DTO는 요청 데이터를 받는 용도
  - Entity는 데이터베이스에 저장하는 용도
  - 둘을 분리해서 관리
- **동작**: `new Board(title, content, username)`로 Board 객체 생성

### 📝 단계 4: Repository에 저장 메서드 추가

**Repository에 추가할 코드**:

```java
@Transactional
public Board save(Board board) {
    entityManager.persist(board);
    return board;
}
```

### 🔍 코드 하나하나 설명

#### 1. `@Transactional`
- **의미**: "이 메서드 안의 모든 작업이 성공하거나 모두 실패해야 한다"
- **왜 필요한가?**: 
  - 데이터베이스 작업의 일관성 보장
  - 중간에 에러가 나면 모든 작업을 취소(롤백)
- **예시**: 저장 중 에러 발생 → 저장 취소

#### 2. `public Board save(Board board)`
- **의미**: 게시글을 데이터베이스에 저장하는 메서드
- **파라미터 `Board board`가 왜 필요한가?**: 
  - 저장할 게시글 데이터를 받아야 함
  - Controller에서 만든 Board 객체를 전달받음
- **왜 Board를 반환하나?**: 
  - 저장된 객체를 반환 (ID가 자동 생성됨)
  - 나중에 저장된 게시글을 확인할 수 있음

#### 3. `entityManager.persist(board);`
- **의미**: 데이터베이스에 저장
- **동작**: JPA가 자동으로 INSERT 쿼리를 생성하고 실행
- **결과**: 데이터베이스에 게시글이 저장됨

### 📝 단계 5: Controller에 저장 메서드 추가

**Controller에 추가할 코드**:

```java
@PostMapping("/board/save")
public String saveProc(BoardRequest.SaveDTO saveDTO) {
    Board board = saveDTO.toEntity();
    repository.save(board);
    return "redirect:/";
}
```

### 🔍 코드 하나하나 설명

#### 1. `@PostMapping("/board/save")`
- **의미**: POST 방식으로 `/board/save` 요청이 오면 실행
- **왜 POST인가?**: 데이터를 저장하는 작업이므로 POST

#### 2. `public String saveProc(BoardRequest.SaveDTO saveDTO)`
- **의미**: 게시글을 저장하는 메서드
- **파라미터 `saveDTO`가 왜 필요한가?**: 
  - 폼에서 보낸 데이터를 받기 위해
  - Spring이 자동으로 폼 데이터를 `SaveDTO` 객체로 변환해줌
  - `name="title"` → `saveDTO.getTitle()`
  - `name="content"` → `saveDTO.getContent()`
  - `name="username"` → `saveDTO.getUsername()`
- **Spring이 어떻게 자동으로 변환하나?**
  - 폼의 `name` 속성과 DTO 필드명이 같으면 자동 매칭
  - 개발자가 직접 파싱할 필요 없음!

#### 3. `Board board = saveDTO.toEntity();`
- **의미**: DTO를 Entity로 변환
- **왜 필요한가?**: 
  - DTO는 요청 데이터를 받는 용도
  - Entity는 데이터베이스에 저장하는 용도
  - Repository는 Entity를 받아야 함

#### 4. `repository.save(board);`
- **의미**: Repository에 저장 요청
- **동작**: 
  1. Repository의 `save()` 메서드 실행
  2. `entityManager.persist(board)` 실행
  3. 데이터베이스에 INSERT 쿼리 실행
  4. 게시글이 저장됨!

#### 5. `return "redirect:/";`
- **의미**: 저장 후 목록 페이지로 이동
- **왜 "redirect:"를 쓰나?**: 
  - 일반 `return "board/list"`는 템플릿을 렌더링
  - `redirect:/`는 브라우저에게 "다시 `/`로 요청해"라고 지시
  - 브라우저가 새로고침하듯이 목록 페이지로 이동
- **왜 필요한가?**: 
  - 저장 후 목록을 보여주기 위해
  - 새로고침 시 중복 저장 방지

### 🎬 전체 동작 흐름

1. **사용자**: "글쓰기" 링크 클릭 → `/board/save` 접속
2. **Controller**: `saveFrom()` 실행 → 작성 폼 페이지 보여줌
3. **사용자**: 제목, 내용, 작성자 입력 후 "글쓰기완료" 버튼 클릭
4. **브라우저**: POST 요청을 `/board/save`로 전송
   - 요청 본문: `username=홍길동&title=안녕&content=반가워요`
5. **Controller**: `saveProc(saveDTO)` 실행
   - Spring이 자동으로 `SaveDTO` 객체 생성 및 값 설정
6. **Controller**: 
   - `saveDTO.toEntity()`로 `Board` 객체 생성
   - `repository.save(board)` 호출
7. **Repository**: 
   - `entityManager.persist(board)` 실행
   - 데이터베이스에 INSERT 쿼리 실행
8. **Controller**: `return "redirect:/"` → 목록 페이지로 이동
9. **브라우저**: 목록 페이지 표시 (새로 작성한 게시글 포함)

### ✅ 목표 3 완료!

이제 게시글을 작성할 수 있습니다!

---

## 목표 4: 게시글 상세보기

### 🎯 목표
특정 게시글의 상세 내용을 보여줍니다.

### 🤔 왜 필요한가요?

목록에서는 제목만 보이죠?
- 사용자가 "이 게시글 내용이 뭐지?" 궁금해함
- 상세보기 페이지가 필요!

### 📝 개발 순서

1. **Repository에 단건 조회 메서드 추가** (ID로 게시글 찾기)
2. **Controller에 상세보기 메서드 추가**
3. **템플릿 만들기**

### 📝 단계 1: Repository에 단건 조회 메서드 추가

**Repository에 추가할 코드**:

```java
public Board findById(Long id) {
    Board board = entityManager.find(Board.class, id);
    return board;
}
```

### 🔍 코드 하나하나 설명

#### 1. `public Board findById(Long id)`
- **의미**: ID로 게시글을 하나 찾는 메서드
- **파라미터 `Long id`가 왜 필요한가?**: 
  - 어떤 게시글을 찾을지 ID를 알아야 함
  - 예: `findById(1)` → 1번 게시글 찾기
- **왜 Board를 반환하나?**: 
  - 찾은 게시글 객체를 반환
  - 없으면 `null` 반환

#### 2. `entityManager.find(Board.class, id)`
- **의미**: Board 클래스에서 id로 찾기
- **동작**: JPA가 자동으로 SELECT 쿼리를 생성하고 실행
- **결과**: 해당 ID의 게시글을 찾아서 Board 객체로 반환

### 📝 단계 2: Controller에 상세보기 메서드 추가

**Controller에 추가할 코드**:

```java
@GetMapping("board/{id}")
public String detail(@PathVariable Long id, Model model) {
    Board board = repository.findById(id);
    if(board == null) {
        throw new RuntimeException("게시글을 찾을 수 없어요 : " + id);
    }
    model.addAttribute("board", board);
    return "board/detail";
}
```

### 🔍 코드 하나하나 설명

#### 1. `@GetMapping("board/{id}")`
- **의미**: GET 방식으로 `board/{id}` 형태의 요청을 처리
- **{id}**: 경로 변수 (가변적인 값)
- **예시**: 
  - `/board/1` → `id = 1`
  - `/board/5` → `id = 5`
- **왜 이렇게 하나?**: 
  - 각 게시글마다 다른 URL이 필요
  - RESTful API 스타일

#### 2. `public String detail(@PathVariable Long id, Model model)`
- **의미**: 게시글 상세보기 메서드
- **@PathVariable Long id가 왜 필요한가?**: 
  - URL의 `{id}` 부분을 변수로 받기 위해
  - `/board/1` → `id = 1`
  - `/board/5` → `id = 5`
- **Model model이 왜 필요한가?**: 
  - 찾은 게시글 데이터를 템플릿에 전달하기 위해
  - 템플릿에서 `{{board.title}}` 등으로 사용할 수 있게 해줌
- **왜 String을 반환하나?**: 템플릿 파일 경로를 반환해야 함

#### 3. `Board board = repository.findById(id);`
- **의미**: Repository에서 해당 ID의 게시글을 찾음
- **동작**: 
  1. `repository.findById(1)` 호출 (예: id=1)
  2. Repository가 데이터베이스에서 1번 게시글 조회
  3. Board 객체로 반환

#### 4. `if(board == null) { ... }`
- **의미**: 게시글이 없으면 에러 발생
- **왜 필요한가?**: 
  - 존재하지 않는 게시글 ID로 접근할 수 있음
  - 예: `/board/999` (999번 게시글이 없을 수 있음)
  - 이런 경우 에러를 발생시켜야 함
- **throw new RuntimeException(...)**: 에러를 발생시킴

#### 5. `model.addAttribute("board", board);`
- **의미**: Model에 게시글 데이터를 추가
- **"board"**: 템플릿에서 사용할 이름
- **board**: 실제 데이터
- **왜 필요한가?**: 템플릿에서 `{{board.title}}` 등으로 사용할 수 있게 해줌

#### 6. `return "board/detail";`
- **의미**: `templates/board/detail.mustache` 파일을 렌더링

### 📝 단계 3: 템플릿 만들기

**파일 위치**: `src/main/resources/templates/board/detail.mustache`

```mustache
{{> layout/header}}

<div class="container p-5">
    <div class="d-flex justify-content-end">
        <b>작성자</b> : {{board.username}}
    </div>
    
    <div>
        <h2><b>{{board.title}}</b></h2>
        <hr />
        <div class="m-4 p-2">
            {{board.content}}
        </div>
    </div>
</div>

{{> layout/footer}}
```

### 🔍 코드 하나하나 설명

#### 1. `{{board.username}}`
- **의미**: Controller에서 전달한 `board` 객체의 `username` 필드 출력
- **동작**: 
  1. Controller에서 `model.addAttribute("board", board)`
  2. 템플릿에서 `{{board.username}}` → "홍길동" 출력

#### 2. `{{board.title}}`, `{{board.content}}`
- **의미**: 제목과 내용 출력
- **동작**: Controller에서 전달한 데이터를 그대로 출력

### 🎬 전체 동작 흐름

1. **사용자**: 목록에서 "상세보기" 링크 클릭 → `/board/1` 접속
2. **브라우저**: GET 요청을 서버로 전송
3. **Spring**: `@GetMapping("board/{id}")`를 찾아서 `detail()` 메서드 실행
4. **Controller**: 
   - `@PathVariable`로 `id = 1` 추출
   - `repository.findById(1)` 호출
   - 게시글 조회
   - `model.addAttribute("board", board)`로 데이터 전달
   - `return "board/detail"`
5. **Spring**: `templates/board/detail.mustache` 파일을 찾음
6. **Mustache**: 
   - `{{board.title}}` → 제목 출력
   - `{{board.content}}` → 내용 출력
   - `{{board.username}}` → 작성자 출력
7. **서버**: 완성된 HTML을 브라우저로 전송
8. **브라우저**: 상세 페이지 표시

### ✅ 목표 4 완료!

이제 게시글 상세보기를 할 수 있습니다!

---

## 목표 5: 게시글 수정하기

### 🎯 목표
기존 게시글을 수정합니다.

### 🤔 왜 필요한가요?

작성한 게시글에 오타가 있거나 내용을 바꾸고 싶을 때:
- 수정 기능이 필요!

### 🤔 수정하기 전에 알아야 할 것

**수정을 하려면 먼저 조회를 해야 합니다!**
- 왜냐하면 수정 폼에 기존 데이터를 채워서 보여줘야 하니까요
- 사용자가 "어떤 내용을 수정할까?" 보면서 수정할 수 있어야 함

### 📝 개발 순서

1. **수정 폼 페이지 만들기** (기존 데이터가 채워진 폼)
2. **수정 처리 기능 만들기** (데이터베이스 업데이트)

### 📝 단계 1: DTO에 UpdateDTO 추가

**BoardRequest.java에 추가할 코드**:

```java
@Data
public static class UpdateDTO {
    private String title;
    private String content;
    private String username;
    
    public void validate() {
        if(title == null || title.trim().isEmpty()) {
            throw new IllegalArgumentException("제목은 필수 입니다");
        }
        if(content == null || content.trim().isEmpty()) {
            throw new IllegalArgumentException("내용은 필수 입니다");
        }
    }
}
```

### 🔍 코드 하나하나 설명

#### 1. `UpdateDTO`
- **의미**: 수정 요청 데이터를 담는 DTO
- **SaveDTO와 비슷하지만**: 수정용이므로 별도로 만듦

#### 2. `public void validate()`
- **의미**: 데이터 유효성 검사
- **왜 필요한가?**: 
  - 제목이나 내용이 비어있으면 안 됨
  - 잘못된 데이터를 막기 위해
- **`title.trim().isEmpty()`**: 
  - `trim()`: 앞뒤 공백 제거
  - `isEmpty()`: 빈 문자열인지 확인
  - 공백만 입력한 경우도 막음

### 📝 단계 2: Board 엔티티에 update 메서드 추가

**Board.java에 추가할 코드**:

```java
public void update(BoardRequest.UpdateDTO updateDTO) {
    updateDTO.validate();
    this.title = updateDTO.getTitle();
    this.content = updateDTO.getContent();
    this.username = updateDTO.getUsername();
}
```

### 🔍 코드 하나하나 설명

#### 1. `public void update(BoardRequest.UpdateDTO updateDTO)`
- **의미**: 게시글을 수정하는 메서드
- **파라미터 `updateDTO`가 왜 필요한가?**: 
  - 수정할 데이터를 받아야 함
  - 사용자가 입력한 새로운 제목, 내용, 작성자
- **왜 void를 반환하나?**: 
  - 단순히 수정만 하고 끝
  - 반환할 값이 없음

#### 2. `updateDTO.validate();`
- **의미**: 데이터 유효성 검사
- **왜 필요한가?**: 잘못된 데이터로 수정하는 것을 방지

#### 3. `this.title = updateDTO.getTitle();`
- **의미**: 현재 객체의 제목을 새로운 제목으로 변경
- **this**: 현재 객체를 가리킴
- **동작**: 
  - `this.title`: 현재 게시글의 제목
  - `updateDTO.getTitle()`: 사용자가 입력한 새로운 제목
  - 새로운 제목으로 교체

### 📝 단계 3: Repository에 수정 메서드 추가

**Repository에 추가할 코드**:

```java
@Transactional
public Board updateById(Long id, BoardRequest.UpdateDTO reqDTO) {
    Board board = entityManager.find(Board.class, id);
    if(board == null) {
        throw new IllegalArgumentException("수정할 게시글을 찾을 수 없어요");
    }
    board.update(reqDTO);
    return board;
}
```

### 🔍 코드 하나하나 설명

#### 1. `@Transactional`
- **의미**: 트랜잭션 관리
- **왜 필요한가?**: 
  - 수정 작업의 일관성 보장
  - 에러 발생 시 롤백

#### 2. `public Board updateById(Long id, BoardRequest.UpdateDTO reqDTO)`
- **의미**: ID로 게시글을 찾아서 수정
- **파라미터가 2개인 이유**: 
  - `Long id`: 어떤 게시글을 수정할지
  - `BoardRequest.UpdateDTO reqDTO`: 어떤 내용으로 수정할지
- **왜 Board를 반환하나?**: 수정된 게시글을 반환

#### 3. `Board board = entityManager.find(Board.class, id);`
- **의미**: 수정할 게시글을 먼저 찾음
- **왜 먼저 찾아야 하나?**: 
  - 수정하려면 기존 게시글이 있어야 함
  - 없으면 수정할 수 없음

#### 4. `if(board == null) { ... }`
- **의미**: 게시글이 없으면 에러 발생
- **왜 필요한가?**: 존재하지 않는 게시글은 수정할 수 없음

#### 5. `board.update(reqDTO);`
- **의미**: Board 객체의 update 메서드 호출
- **동작**: 
  1. `update()` 메서드가 실행됨
  2. `this.title = updateDTO.getTitle()` 등으로 값 변경
  3. **더티 체킹(Dirty Checking)**:
     - JPA가 엔티티의 변경사항을 자동으로 감지
     - 트랜잭션 종료 시 자동으로 UPDATE 쿼리 실행
     - 개발자가 직접 UPDATE 쿼리를 작성할 필요 없음!

**더티 체킹이 뭔가요?**
- JPA가 엔티티의 변경사항을 자동으로 감지하는 기능
- 장점:
  - 변경된 필드만 자동으로 UPDATE
  - 코드가 간결해짐
  - 실수로 UPDATE 쿼리를 빼먹을 일이 없음

### 📝 단계 4: Controller에 수정 폼 메서드 추가

**Controller에 추가할 코드**:

```java
@GetMapping("/board/{id}/update")
public String updateForm(@PathVariable Long id, Model model) {
    Board board = repository.findById(id);
    if(board == null) {
        throw new RuntimeException("수정할 게시글을 찾을 수 없어요");
    }
    model.addAttribute("board", board);
    return "board/update-form";
}
```

### 🔍 코드 하나하나 설명

#### 1. `@GetMapping("/board/{id}/update")`
- **의미**: GET 방식으로 `/board/{id}/update` 요청 처리
- **예시**: `/board/1/update` → 1번 게시글 수정 폼

#### 2. `public String updateForm(@PathVariable Long id, Model model)`
- **의미**: 수정 폼 페이지를 보여주는 메서드
- **@PathVariable Long id가 왜 필요한가?**: 
  - 어떤 게시글을 수정할지 ID를 알아야 함
  - URL에서 `{id}` 부분을 추출
- **Model model이 왜 필요한가?**: 
  - 기존 게시글 데이터를 템플릿에 전달하기 위해
  - 수정 폼에 기존 데이터를 채워서 보여줘야 함

#### 3. `Board board = repository.findById(id);`
- **의미**: 수정할 게시글을 먼저 조회
- **왜 먼저 조회하나?**: 
  - 수정 폼에 기존 데이터를 채워서 보여줘야 함
  - 사용자가 "어떤 내용이었지?" 보면서 수정할 수 있게

#### 4. `model.addAttribute("board", board);`
- **의미**: 기존 게시글 데이터를 템플릿에 전달
- **왜 필요한가?**: 템플릿에서 `{{board.title}}` 등으로 기존 데이터를 표시

### 📝 단계 5: 템플릿 만들기

**파일 위치**: `src/main/resources/templates/board/update-form.mustache`

```mustache
{{> layout/header}}

<div class="container p-5">
    <div class="card">
        <div class="card-header"><b>글수정 화면입니다</b></div>
        <div class="card-body">
            <form action="/board/{{board.id}}/update" method="post">
                <div class="mb-3">
                    <input type="text" class="form-control" 
                           placeholder="Enter username" 
                           name="username" value="{{board.username}}">
                </div>
                <div class="mb-3">
                    <input type="text" class="form-control" 
                           placeholder="Enter title" 
                           name="title" value="{{board.title}}">
                </div>
                <div class="mb-3">
                    <textarea class="form-control" rows="5" 
                              name="content">{{board.content}}</textarea>
                </div>
                <button class="btn btn-primary form-control">수정완료</button>
            </form>
        </div>
    </div>
</div>

{{> layout/footer}}
```

### 🔍 코드 하나하나 설명

#### 1. `action="/board/{{board.id}}/update"`
- **의미**: 폼 제출 시 `/board/1/update` 같은 경로로 요청
- **{{board.id}}**: 현재 게시글의 ID
- **왜 ID가 필요한가?**: 어떤 게시글을 수정할지 알아야 함

#### 2. `value="{{board.username}}"`
- **의미**: 입력 필드에 기존 값을 채워넣음
- **왜 필요한가?**: 
  - 사용자가 기존 데이터를 보면서 수정할 수 있게
  - 빈 폼이 아니라 기존 데이터가 채워진 폼

#### 3. `<textarea>{{board.content}}</textarea>`
- **의미**: textarea 태그는 `value` 속성이 없고 태그 사이에 값을 넣음
- **동작**: 기존 내용이 textarea 안에 표시됨

### 📝 단계 6: Controller에 수정 처리 메서드 추가

**Controller에 추가할 코드**:

```java
@PostMapping("/board/{id}/update")
public String updateProc(@PathVariable Long id,
                         BoardRequest.UpdateDTO updateDTO) {
    try {
        repository.updateById(id, updateDTO);
    } catch (Exception e) {
        throw new RuntimeException("게시글 수정 실패");
    }
    return "redirect:/board/list";
}
```

### 🔍 코드 하나하나 설명

#### 1. `@PostMapping("/board/{id}/update")`
- **의미**: POST 방식으로 `/board/{id}/update` 요청 처리
- **왜 POST인가?**: 데이터를 수정하는 작업이므로 POST

#### 2. `public String updateProc(@PathVariable Long id, BoardRequest.UpdateDTO updateDTO)`
- **의미**: 게시글을 수정하는 메서드
- **파라미터가 2개인 이유**: 
  - `@PathVariable Long id`: 어떤 게시글을 수정할지
  - `BoardRequest.UpdateDTO updateDTO`: 어떤 내용으로 수정할지
- **Spring이 자동으로 처리**: 
  - URL의 `{id}` → `id` 변수에 자동 할당
  - 폼 데이터 → `updateDTO` 객체로 자동 변환

#### 3. `try { ... } catch { ... }`
- **의미**: 에러가 발생할 수 있으므로 처리
- **왜 필요한가?**: 
  - 수정 중 에러가 발생할 수 있음
  - 예: 데이터베이스 연결 실패, 유효성 검사 실패 등
  - 에러를 잡아서 처리

#### 4. `repository.updateById(id, updateDTO);`
- **의미**: Repository에 수정 요청
- **동작**: 
  1. Repository에서 게시글 조회
  2. `board.update(updateDTO)` 호출
  3. 더티 체킹으로 자동 UPDATE 쿼리 실행
  4. 데이터베이스에 반영

#### 5. `return "redirect:/board/list";`
- **의미**: 수정 후 목록 페이지로 이동
- **왜 redirect를 쓰나?**: 
  - 수정 후 목록을 보여주기 위해
  - 새로고침 시 중복 수정 방지

### 🎬 전체 동작 흐름

1. **사용자**: 상세 페이지에서 "수정" 버튼 클릭 → `/board/1/update` 접속
2. **Controller**: `updateForm()` 실행
   - `repository.findById(1)` 호출
   - 게시글 조회
   - `model.addAttribute("board", board)`로 데이터 전달
   - `return "board/update-form"`
3. **브라우저**: 수정 폼 페이지 표시 (기존 데이터가 채워져 있음)
4. **사용자**: 내용 수정 후 "수정완료" 버튼 클릭
5. **브라우저**: POST 요청을 `/board/1/update`로 전송
   - 요청 본문: `username=홍길동&title=수정된제목&content=수정된내용`
6. **Controller**: `updateProc()` 실행
   - `@PathVariable`로 `id = 1` 추출
   - Spring이 자동으로 `UpdateDTO` 객체 생성 및 값 설정
   - `repository.updateById(1, updateDTO)` 호출
7. **Repository**: 
   - 게시글 조회
   - `board.update(updateDTO)` 호출
   - 더티 체킹으로 자동 UPDATE 쿼리 실행
8. **Controller**: `return "redirect:/board/list"` → 목록 페이지로 이동
9. **브라우저**: 목록 페이지 표시 (수정된 내용 반영)

### ✅ 목표 5 완료!

이제 게시글을 수정할 수 있습니다!

---

## 목표 6: 게시글 삭제하기

### 🎯 목표
게시글을 삭제합니다.

### 🤔 왜 필요한가요?

작성한 게시글이 더 이상 필요 없을 때:
- 삭제 기능이 필요!

### 📝 개발 순서

1. **Repository에 삭제 메서드 추가**
2. **Controller에 삭제 메서드 추가**
3. **템플릿에 삭제 버튼 추가** (이미 detail.mustache에 있음)

### 📝 단계 1: Repository에 삭제 메서드 추가

**Repository에 추가할 코드**:

```java
@Transactional
public void deleteById(Long id) {
    Board board = entityManager.find(Board.class, id);
    if(board == null) {
        throw new IllegalArgumentException("삭제할 게시글이 없어요");
    }
    entityManager.remove(board);
}
```

### 🔍 코드 하나하나 설명

#### 1. `@Transactional`
- **의미**: 트랜잭션 관리
- **왜 필요한가?**: 삭제 작업의 일관성 보장

#### 2. `public void deleteById(Long id)`
- **의미**: ID로 게시글을 삭제하는 메서드
- **파라미터 `Long id`가 왜 필요한가?**: 
  - 어떤 게시글을 삭제할지 ID를 알아야 함
  - 예: `deleteById(1)` → 1번 게시글 삭제
- **왜 void를 반환하나?**: 
  - 삭제만 하고 끝
  - 반환할 값이 없음

#### 3. `Board board = entityManager.find(Board.class, id);`
- **의미**: 삭제할 게시글을 먼저 찾음
- **왜 먼저 찾아야 하나?**: 
  - 삭제하려면 기존 게시글이 있어야 함
  - 없으면 삭제할 수 없음

#### 4. `if(board == null) { ... }`
- **의미**: 게시글이 없으면 에러 발생
- **왜 필요한가?**: 존재하지 않는 게시글은 삭제할 수 없음

#### 5. `entityManager.remove(board);`
- **의미**: 게시글을 삭제
- **동작**: JPA가 자동으로 DELETE 쿼리를 생성하고 실행
- **결과**: 데이터베이스에서 게시글이 삭제됨

### 📝 단계 2: Controller에 삭제 메서드 추가

**Controller에 추가할 코드**:

```java
@PostMapping("/board/{id}/delete")
public String delete(@PathVariable Long id) {
    repository.deleteById(id);
    return "redirect:/";
}
```

### 🔍 코드 하나하나 설명

#### 1. `@PostMapping("/board/{id}/delete")`
- **의미**: POST 방식으로 `/board/{id}/delete` 요청 처리
- **왜 POST인가?**: 데이터를 삭제하는 작업이므로 POST
- **예시**: `/board/1/delete` → 1번 게시글 삭제

#### 2. `public String delete(@PathVariable Long id)`
- **의미**: 게시글을 삭제하는 메서드
- **@PathVariable Long id가 왜 필요한가?**: 
  - 어떤 게시글을 삭제할지 ID를 알아야 함
  - URL의 `{id}` 부분을 추출
- **왜 Model이 없나?**: 
  - 삭제만 하고 끝
  - 템플릿에 데이터를 전달할 필요가 없음
- **왜 String을 반환하나?**: 
  - 삭제 후 다른 페이지로 이동해야 함
  - `redirect` 문자열을 반환해야 함

#### 3. `repository.deleteById(id);`
- **의미**: Repository에 삭제 요청
- **동작**: 
  1. Repository에서 게시글 조회
  2. `entityManager.remove(board)` 실행
  3. DELETE 쿼리 실행
  4. 데이터베이스에서 삭제

#### 4. `return "redirect:/";`
- **의미**: 삭제 후 목록 페이지로 이동
- **왜 redirect를 쓰나?**: 
  - 삭제 후 목록을 보여주기 위해
  - 새로고침 시 중복 삭제 방지 (이미 삭제되었으므로)

### 📝 단계 3: 템플릿에 삭제 버튼 확인

**detail.mustache에 이미 있는 코드**:

```mustache
<form action="/board/{{board.id}}/delete" method="post">
    <button class="btn btn-danger">삭제</button>
</form>
```

### 🔍 코드 하나하나 설명

#### 1. `<form action="/board/{{board.id}}/delete" method="post">`
- **의미**: 폼 제출 시 `/board/1/delete` 같은 경로로 POST 요청
- **{{board.id}}**: 현재 게시글의 ID
- **method="post"**: POST 방식으로 전송
- **왜 POST인가?**: 삭제는 중요한 작업이므로 POST 사용

#### 2. `<button class="btn btn-danger">삭제</button>`
- **의미**: 삭제 버튼
- **동작**: 버튼 클릭 시 폼이 제출됨

### 🎬 전체 동작 흐름

1. **사용자**: 상세 페이지에서 "삭제" 버튼 클릭
2. **브라우저**: POST 요청을 `/board/1/delete`로 전송
3. **Controller**: `delete()` 실행
   - `@PathVariable`로 `id = 1` 추출
   - `repository.deleteById(1)` 호출
4. **Repository**: 
   - 게시글 조회
   - `entityManager.remove(board)` 실행
   - DELETE 쿼리 실행
   - 데이터베이스에서 삭제
5. **Controller**: `return "redirect:/"` → 목록 페이지로 이동
6. **브라우저**: 목록 페이지 표시 (삭제된 게시글은 보이지 않음)

### ✅ 목표 6 완료!

이제 게시글을 삭제할 수 있습니다!

---

## 🎉 수업 완료!

### 완성된 기능들

1. ✅ **게시글 목록 보기**: 모든 게시글을 목록으로 표시
2. ✅ **게시글 작성하기**: 새 게시글을 작성하고 저장
3. ✅ **게시글 상세보기**: 특정 게시글의 상세 내용 확인
4. ✅ **게시글 수정하기**: 기존 게시글 수정
5. ✅ **게시글 삭제하기**: 게시글 삭제

### 배운 핵심 개념들

1. **Entity**: 데이터베이스 테이블과 연결되는 클래스
2. **Repository**: 데이터베이스 작업을 담당하는 클래스
3. **Controller**: 웹 요청을 처리하는 클래스
4. **DTO**: 데이터 전송 객체
5. **Model**: 템플릿에 데이터를 전달하는 객체
6. **Mustache**: 서버에서 HTML을 생성하는 템플릿 엔진
7. **어노테이션**: Spring이 자동으로 처리하도록 지시하는 표시
8. **IoC/DI**: Spring이 객체를 자동으로 생성하고 주입

### 왜 이렇게 만들었나요?

#### 1. 왜 파라미터가 필요한가요?
- 메서드가 작업을 수행하려면 필요한 정보를 받아야 함
- 예: `findById(Long id)` → 어떤 게시글을 찾을지 ID가 필요

#### 2. 왜 Model이 필요한가요?
- Controller에서 템플릿으로 데이터를 전달하기 위해
- Model 없이는 템플릿에 데이터를 보낼 수 없음

#### 3. 왜 String을 반환하나요?
- 템플릿 파일 경로를 반환해야 함
- Spring이 이 경로를 보고 템플릿을 찾아서 렌더링

#### 4. 왜 void를 쓰나요?
- 단순히 작업만 수행하고 결과를 반환할 필요가 없을 때
- 예: 삭제 작업

#### 5. 왜 DTO와 Entity를 분리하나요?
- DTO: 요청/응답 데이터 전송용
- Entity: 데이터베이스 저장용
- 분리하면 보안, 유연성, 책임 분리가 쉬워짐

### 다음 단계

이제 기본 CRUD 기능을 모두 배웠습니다!
- 더 공부하고 싶다면: 인증/인가, 댓글 기능, 파일 업로드 등
- 실전 프로젝트에 적용해보세요!

---

**수고하셨습니다! 🎊**

