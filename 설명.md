# Mustache 템플릿 엔진 수업 자료 상세 설명

## 목차
1. [프로젝트 개요](#프로젝트-개요)
2. [Java 기본 개념](#java-기본-개념)
3. [Spring Boot 기본 개념](#spring-boot-기본-개념)
4. [어노테이션(Annotation) 상세 설명](#어노테이션annotation-상세-설명)
5. [프로젝트 구조 설명](#프로젝트-구조-설명)
6. [각 파일별 상세 설명](#각-파일별-상세-설명)
7. [Mustache 템플릿 엔진](#mustache-템플릿-엔진)
8. [전체 동작 흐름](#전체-동작-흐름)

---

## 프로젝트 개요

이 프로젝트는 **Spring Boot**와 **Mustache 템플릿 엔진**을 사용한 **SSR(Server-Side Rendering)** 블로그 애플리케이션입니다.

### SSR이란?
- **SSR (Server-Side Rendering)**: 서버에서 HTML을 완성해서 클라이언트(브라우저)에게 보내는 방식
- 반대 개념: **CSR (Client-Side Rendering)**: 클라이언트(브라우저)에서 JavaScript로 HTML을 만드는 방식
- 이 프로젝트는 서버에서 Mustache 템플릿을 사용해 HTML을 완성해서 보냅니다.

---

## Java 기본 개념

### 1. public이란?

```java
public class BoardController {
    public String boardList() {
        // ...
    }
}
```

**public**은 **접근 제어자(Access Modifier)**입니다.

- **의미**: "누구나 접근할 수 있다"는 뜻
- **왜 사용하나?**: 
  - 다른 클래스에서 이 클래스나 메서드를 사용할 수 있게 하기 위해
  - Spring Framework가 이 클래스를 찾아서 사용할 수 있게 하기 위해
- **다른 접근 제어자**:
  - `private`: 같은 클래스 내에서만 사용 가능
  - `protected`: 같은 패키지 또는 상속받은 클래스에서 사용 가능
  - `default` (아무것도 안 씀): 같은 패키지에서만 사용 가능

### 2. String이란?

```java
public String boardList() {
    return "board/list";
}
```

**String**은 **문자열(텍스트)을 저장하는 데이터 타입**입니다.

- **의미**: "문자들의 나열"을 저장하는 타입
- **예시**: `"안녕하세요"`, `"board/list"`, `"홍길동"` 등
- **왜 사용하나?**:
  - 템플릿 파일 경로를 반환할 때 사용 (예: `"board/list"`)
  - 사용자 이름, 제목, 내용 등 텍스트 데이터를 저장할 때 사용
- **다른 기본 타입**:
  - `int`: 정수 (1, 2, 3...)
  - `long`: 큰 정수
  - `boolean`: true/false
  - `double`: 소수점 숫자

### 3. void란?

```java
public void deleteById(Long id) {
    repository.deleteById(id);
}
```

**void**는 **"아무것도 반환하지 않는다"**는 뜻입니다.

- **의미**: 이 메서드는 결과값을 돌려주지 않는다
- **왜 사용하나?**:
  - 단순히 작업만 수행하고 결과를 반환할 필요가 없을 때
  - 예: 삭제 작업, 출력 작업 등
- **반대 개념**: 
  - `String`, `int`, `Board` 등: 메서드가 특정 값을 반환함
  - 예: `public String boardList()` → "board/list"라는 문자열을 반환

### 4. static이란?

```java
public static void main(String[] args) {
    SpringApplication.run(DemoSsrV11Application.class, args);
}
```

**static**은 **"클래스에 속한 것"**이라는 뜻입니다.

- **의미**: 객체를 만들지 않아도 사용할 수 있는 것
- **왜 사용하나?**:
  - `main` 메서드는 프로그램 시작점이므로 객체 없이 바로 실행되어야 함
  - 클래스 이름으로 바로 접근 가능
- **일반 메서드와의 차이**:
  - 일반 메서드: 객체를 만들어야 사용 가능 (`new BoardController()`)
  - static 메서드: 객체 없이 사용 가능 (`DemoSsrV11Application.main()`)

---

## Spring Boot 기본 개념

### Spring Boot란?

**Spring Boot**는 Java로 웹 애플리케이션을 쉽게 만들 수 있게 해주는 프레임워크입니다.

- **프레임워크**: 개발을 쉽게 해주는 도구들의 모음
- **특징**:
  - 설정이 간단함
  - 내장 서버 포함 (별도 서버 설치 불필요)
  - 자동 설정 기능

### IoC (Inversion of Control) - 제어의 역전

**IoC**는 "객체를 직접 만들지 않고, Spring이 대신 만들어주고 관리해주는 것"입니다.

```java
@Controller
public class BoardController {
    private final BoardPersistRepository repository;
    // Spring이 자동으로 repository 객체를 만들어서 넣어줌
}
```

- **일반적인 방식**: 개발자가 직접 `new BoardController()`로 객체 생성
- **IoC 방식**: Spring이 자동으로 객체를 생성하고 관리
- **장점**: 객체 간 의존성을 Spring이 관리해줌

### DI (Dependency Injection) - 의존성 주입

**DI**는 "필요한 객체를 Spring이 자동으로 넣어주는 것"입니다.

```java
@RequiredArgsConstructor
public class BoardController {
    private final BoardPersistRepository repository;
    // Spring이 자동으로 repository를 주입해줌
}
```

- **의미**: 클래스가 필요로 하는 다른 객체를 Spring이 자동으로 제공
- **방법**: 
  - `@RequiredArgsConstructor` 어노테이션 사용
  - 또는 `@Autowired` 어노테이션 사용

---

## 어노테이션(Annotation) 상세 설명

**어노테이션**은 코드에 붙이는 **특별한 표시**입니다. `@` 기호로 시작합니다.

### 1. @SpringBootApplication

```java
@SpringBootApplication
public class DemoSsrV11Application {
    // ...
}
```

- **의미**: "이 클래스가 Spring Boot 애플리케이션의 시작점이다"
- **역할**:
  - Spring Boot 자동 설정 활성화
  - 컴포넌트 스캔 시작 (다른 클래스들을 찾아서 등록)
  - 내장 서버 시작

### 2. @Controller

```java
@Controller
public class BoardController {
    // ...
}
```

- **의미**: "이 클래스가 웹 요청을 처리하는 컨트롤러다"
- **역할**:
  - 사용자의 HTTP 요청을 받아서 처리
  - Spring이 이 클래스를 찾아서 등록
  - 웹 페이지를 반환하는 역할

### 3. @Repository

```java
@Repository
public class BoardPersistRepository {
    // ...
}
```

- **의미**: "이 클래스가 데이터베이스와 소통하는 저장소다"
- **역할**:
  - 데이터베이스 작업 (CRUD)을 담당
  - Spring이 이 클래스를 찾아서 등록
  - 예외 처리 자동 변환

### 4. @Entity

```java
@Entity
public class Board {
    // ...
}
```

- **의미**: "이 클래스가 데이터베이스 테이블과 연결되는 엔티티다"
- **역할**:
  - 데이터베이스의 `board_tb` 테이블과 매핑
  - JPA가 이 클래스를 데이터베이스 테이블로 인식

### 5. @Table(name = "board_tb")

```java
@Table(name = "board_tb")
@Entity
public class Board {
    // ...
}
```

- **의미**: "이 엔티티는 `board_tb`라는 테이블과 연결된다"
- **역할**: 클래스 이름(`Board`)과 테이블 이름(`board_tb`)이 다를 때 사용

### 6. @Id

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

- **의미**: "이 필드가 기본 키(Primary Key)다"
- **역할**: 데이터베이스에서 각 행을 구분하는 고유한 값

### 7. @GeneratedValue(strategy = GenerationType.IDENTITY)

```java
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

- **의미**: "이 값은 데이터베이스가 자동으로 생성해준다"
- **역할**: 새 데이터를 저장할 때 ID를 자동으로 1, 2, 3... 순서대로 생성

### 8. @CreationTimestamp

```java
@CreationTimestamp
private Timestamp createdAt;
```

- **의미**: "이 필드는 데이터가 생성될 때 자동으로 현재 시간이 저장된다"
- **역할**: 게시글 작성 시간을 자동으로 기록

### 9. @GetMapping("/board/list")

```java
@GetMapping("/board/list")
public String boardList(Model model) {
    // ...
}
```

- **의미**: "GET 방식으로 `/board/list` 요청이 오면 이 메서드를 실행한다"
- **역할**: 
  - 웹 브라우저에서 주소창에 입력하거나 링크를 클릭할 때 사용
  - 데이터를 조회할 때 주로 사용

### 10. @PostMapping("/board/save")

```java
@PostMapping("/board/save")
public String saveProc(BoardRequest.SaveDTO saveDTO) {
    // ...
}
```

- **의미**: "POST 방식으로 `/board/save` 요청이 오면 이 메서드를 실행한다"
- **역할**:
  - 폼(form) 제출 시 사용
  - 데이터를 저장하거나 수정할 때 주로 사용
  - GET과 달리 요청 본문에 데이터를 숨겨서 전송

### 11. @PathVariable

```java
@GetMapping("/board/{id}")
public String detail(@PathVariable Long id, Model model) {
    // ...
}
```

- **의미**: "URL 경로에 있는 `{id}` 값을 이 변수에 넣어준다"
- **예시**: 
  - URL: `/board/1` → `id = 1`
  - URL: `/board/5` → `id = 5`

### 12. @Transactional

```java
@Transactional
public Board save(Board board) {
    entityManager.persist(board);
    return board;
}
```

- **의미**: "이 메서드 안의 모든 작업이 성공하거나 모두 실패해야 한다"
- **역할**: 
  - 데이터베이스 작업의 일관성 보장
  - 중간에 에러가 나면 모든 작업을 취소(롤백)

### 13. @Data (Lombok)

```java
@Data
public static class SaveDTO {
    private String title;
    // ...
}
```

- **의미**: "자동으로 getter, setter, toString 등을 만들어준다"
- **역할**: 
  - `getTitle()`, `setTitle()` 같은 메서드를 자동 생성
  - 코드를 간결하게 만들어줌

### 14. @RequiredArgsConstructor (Lombok)

```java
@RequiredArgsConstructor
public class BoardController {
    private final BoardPersistRepository repository;
}
```

- **의미**: "final 필드에 대한 생성자를 자동으로 만들어준다"
- **역할**: 
  - DI(의존성 주입)를 위해 생성자를 자동 생성
  - `new BoardController(repository)` 같은 생성자 자동 생성

### 15. @NoArgsConstructor (Lombok)

```java
@NoArgsConstructor
public class Board {
    // ...
}
```

- **의미**: "매개변수 없는 생성자를 자동으로 만들어준다"
- **역할**: JPA가 객체를 만들 때 필요

---

## 프로젝트 구조 설명

```
src/main/java/org/example/demo_ssr_v1_1/
├── DemoSsrV11Application.java    # 프로그램 시작점
├── board/                         # 게시판 관련 코드
│   ├── Board.java                 # 게시글 엔티티 (데이터베이스 테이블과 연결)
│   ├── BoardController.java      # 웹 요청 처리
│   ├── BoardRequest.java          # 요청 데이터 전송 객체 (DTO)
│   └── BoardPersistRepository.java # 데이터베이스 작업
└── user/                          # 사용자 관련 코드
    └── User.java                  # 사용자 엔티티

src/main/resources/
├── application.yml                # 설정 파일
├── templates/                     # Mustache 템플릿 파일들
│   ├── board/
│   │   ├── list.mustache         # 게시글 목록 페이지
│   │   ├── detail.mustache       # 게시글 상세 페이지
│   │   ├── save-form.mustache    # 게시글 작성 페이지
│   │   └── update-form.mustache  # 게시글 수정 페이지
│   └── layout/
│       ├── header.mustache        # 공통 헤더
│       └── footer.mustache        # 공통 푸터
└── db/
    └── data.sql                   # 초기 데이터
```

---

## 각 파일별 상세 설명

### 1. DemoSsrV11Application.java

```java
package org.example.demo_ssr_v1_1;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoSsrV11Application {

    public static void main(String[] args) {
        SpringApplication.run(DemoSsrV11Application.class, args);
    }

}
```

**역할**: 프로그램의 시작점

**상세 설명**:
- `@SpringBootApplication`: 이 클래스가 Spring Boot 애플리케이션임을 알림
- `public static void main(String[] args)`: 프로그램이 시작되는 진입점
  - `public`: 어디서든 접근 가능
  - `static`: 객체 없이 실행 가능
  - `void`: 반환값 없음
  - `String[] args`: 명령줄 인자 (이 프로젝트에서는 사용 안 함)
- `SpringApplication.run()`: Spring Boot 애플리케이션을 실행
  - 내장 서버(Tomcat) 시작
  - 모든 설정 로드
  - 컴포넌트 스캔 시작

---

### 2. Board.java (Entity)

```java
@Entity
@Table(name = "board_tb")
public class Board {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String title;
    private String content;
    private String username;
    
    @CreationTimestamp
    private Timestamp createdAt;
}
```

**역할**: 데이터베이스의 `board_tb` 테이블과 연결되는 클래스

**상세 설명**:
- **Entity란?**: 데이터베이스 테이블을 Java 클래스로 표현한 것
- **필드 설명**:
  - `id`: 게시글 고유 번호 (자동 생성)
  - `title`: 게시글 제목
  - `content`: 게시글 내용
  - `username`: 작성자 이름
  - `createdAt`: 작성 시간 (자동 생성)
- **@Data**: Lombok이 자동으로 getter/setter 생성
  - 예: `getId()`, `setId()`, `getTitle()`, `setTitle()` 등
- **@NoArgsConstructor**: 매개변수 없는 생성자 자동 생성
  - JPA가 객체를 만들 때 필요

**메서드 설명**:
- `public Board(String title, String content, String username)`: 생성자
  - 새 게시글을 만들 때 사용
- `public void update(BoardRequest.UpdateDTO updateDTO)`: 게시글 수정 메서드
  - 제목, 내용, 작성자를 한 번에 수정

---

### 3. BoardController.java

**역할**: 사용자의 웹 요청을 받아서 처리하는 클래스

**전체 구조**:
```java
@Controller
@RequiredArgsConstructor
public class BoardController {
    private final BoardPersistRepository repository;
    
    // 여러 메서드들...
}
```

**상세 설명**:

#### 3-1. 필드
```java
private final BoardPersistRepository repository;
```
- **의미**: 데이터베이스 작업을 할 수 있는 저장소
- **final**: 한 번 할당되면 변경 불가 (안전성)
- **DI**: Spring이 자동으로 객체를 넣어줌

#### 3-2. 게시글 목록 조회
```java
@GetMapping({"/board/list", "/"})
public String boardList(Model model) {
    List<Board> boardList = repository.findAll();
    model.addAttribute("boardList", boardList);
    return "board/list";
}
```

**동작 과정**:
1. 사용자가 `/board/list` 또는 `/`로 접속 (GET 요청)
2. `repository.findAll()`: 데이터베이스에서 모든 게시글 가져오기
3. `model.addAttribute("boardList", boardList)`: 
   - 템플릿에 전달할 데이터를 모델에 추가
   - 템플릿에서 `{{#boardList}}`로 사용 가능
4. `return "board/list"`: `templates/board/list.mustache` 파일을 렌더링

**왜 String을 반환하나?**
- Spring이 반환된 문자열을 템플릿 파일 경로로 인식
- `"board/list"` → `templates/board/list.mustache` 파일을 찾아서 렌더링

#### 3-3. 게시글 작성 폼
```java
@GetMapping("/board/save")
public String saveFrom() {
    return "board/save-form";
}
```

**동작 과정**:
1. 사용자가 `/board/save`로 접속 (GET 요청)
2. `return "board/save-form"`: 작성 폼 페이지를 보여줌
3. 데이터 전달 없이 단순히 페이지만 보여줌

**왜 void가 아닌가?**
- 페이지를 보여주려면 템플릿 파일 경로를 반환해야 함
- `void`를 쓰면 Spring이 어떤 페이지를 보여줄지 모름

#### 3-4. 게시글 저장
```java
@PostMapping("/board/save")
public String saveProc(BoardRequest.SaveDTO saveDTO) {
    Board board = saveDTO.toEntity();
    repository.save(board);
    return "redirect:/";
}
```

**동작 과정**:
1. 사용자가 작성 폼에서 "글쓰기완료" 버튼 클릭 (POST 요청)
2. 폼 데이터가 `BoardRequest.SaveDTO` 객체로 자동 변환
   - `name="title"` → `saveDTO.getTitle()`
   - `name="content"` → `saveDTO.getContent()`
   - `name="username"` → `saveDTO.getUsername()`
3. `saveDTO.toEntity()`: DTO를 Entity로 변환
4. `repository.save(board)`: 데이터베이스에 저장
5. `return "redirect:/"`: 저장 후 목록 페이지로 이동

**왜 String을 반환하나?**
- `"redirect:/"`는 특별한 문자열
- Spring이 이것을 보고 페이지 이동(리다이렉트)을 수행
- 새로고침 시 중복 저장 방지

#### 3-5. 게시글 상세보기
```java
@GetMapping("board/{id}")
public String detail(@PathVariable Long id, Model model) {
    Board board = repository.findById(id);
    if(board == null) {
        throw new RuntimeException("게시글을 찾을 수 없어요 : " + id);
    }
    model.addAttribute("board", board);
    return "board/detail";
}
```

**동작 과정**:
1. 사용자가 `/board/1`로 접속 (GET 요청)
2. `@PathVariable Long id`: URL의 `{id}` 부분을 변수에 저장
   - `/board/1` → `id = 1`
   - `/board/5` → `id = 5`
3. `repository.findById(id)`: 해당 ID의 게시글 조회
4. `if(board == null)`: 게시글이 없으면 에러 발생
5. `model.addAttribute("board", board)`: 템플릿에 게시글 데이터 전달
6. `return "board/detail"`: 상세 페이지 렌더링

#### 3-6. 게시글 수정 폼
```java
@GetMapping("/board/{id}/update")
public String updateForm(@PathVariable Long id, Model model) {
    Board board = repository.findById(id);
    if(board == null) {
        throw new RuntimeException("수정할 게시글을 찾을 수 없어요");
    }
    model.addAttribute("board", board);
    return "board/update-form";
}
```

**동작 과정**:
1. 사용자가 `/board/1/update`로 접속 (GET 요청)
2. 게시글을 조회해서 수정 폼에 기존 데이터를 채워서 보여줌
3. 사용자가 수정할 수 있도록 폼에 데이터 전달

#### 3-7. 게시글 수정 처리
```java
@PostMapping("/board/{id}/update")
public String updateProc(@PathVariable Long id,
                         BoardRequest.UpdateDTO updateDTO) {
    try {
        repository.updateById(id, updateDTO);
    } catch (Exception e) {
        throw new RuntimeException("게시글 수정 실패");
    }
    return "redirect:/board/list";
}
```

**동작 과정**:
1. 수정 폼에서 "수정완료" 버튼 클릭 (POST 요청)
2. `updateDTO`: 수정된 데이터가 자동으로 객체로 변환
3. `repository.updateById(id, updateDTO)`: 데이터베이스 업데이트
4. `return "redirect:/board/list"`: 수정 후 목록 페이지로 이동

#### 3-8. 게시글 삭제
```java
@PostMapping("/board/{id}/delete")
public String delete(@PathVariable Long id) {
    repository.deleteById(id);
    return "redirect:/";
}
```

**동작 과정**:
1. 삭제 버튼 클릭 (POST 요청)
2. `repository.deleteById(id)`: 데이터베이스에서 삭제
3. `return "redirect:/"`: 삭제 후 목록 페이지로 이동

**왜 void가 아닌가?**
- 삭제 후 다른 페이지로 이동해야 하므로 `redirect` 문자열 반환 필요

---

### 4. BoardRequest.java (DTO)

**역할**: 클라이언트(브라우저)에서 서버로 전송되는 데이터를 담는 객체

**DTO란?**
- **Data Transfer Object**: 데이터 전송 객체
- 컨트롤러와 비즈니스 로직 사이에서 데이터를 전달하는 용도
- Entity와 분리하는 이유: 보안, 유효성 검사 등

**전체 구조**:
```java
public class BoardRequest {
    
    @Data
    public static class SaveDTO {
        private String title;
        private String content;
        private String username;
        
        public Board toEntity() {
            return new Board(title, content, username);
        }
    }
    
    @Data
    public static class UpdateDTO {
        private String title;
        private String content;
        private String username;
        
        public void validate() {
            if(title == null || title.trim().isEmpty()) {
                throw new IllegalArgumentException("제목은 필수 입니다");
            }
            if(content == null || content.trim().isEmpty()) {
                throw new IllegalArgumentException("내용은 필수 입니다");
            }
        }
    }
}
```

**상세 설명**:

#### 4-1. 정적 내부 클래스
- `public static class SaveDTO`: 정적 내부 클래스
- **왜 사용하나?**: 관련된 클래스들을 한 곳에 모아서 관리
- `BoardRequest.SaveDTO`로 사용

#### 4-2. SaveDTO
- **역할**: 게시글 저장 시 전달되는 데이터
- **필드**:
  - `title`: 제목
  - `content`: 내용
  - `username`: 작성자
- **toEntity() 메서드**:
  - DTO를 Entity로 변환
  - `new Board(title, content, username)`: Board 객체 생성

**동작 과정**:
1. 사용자가 폼에서 데이터 입력
2. Spring이 자동으로 `SaveDTO` 객체 생성
3. 폼의 `name` 속성과 DTO 필드명이 같으면 자동으로 값 설정
4. `toEntity()`로 `Board` 객체로 변환
5. 데이터베이스에 저장

#### 4-3. UpdateDTO
- **역할**: 게시글 수정 시 전달되는 데이터
- **validate() 메서드**:
  - 데이터 유효성 검사
  - 제목이나 내용이 비어있으면 에러 발생
  - `trim()`: 앞뒤 공백 제거
  - `isEmpty()`: 빈 문자열인지 확인

---

### 5. BoardPersistRepository.java

**역할**: 데이터베이스와 직접 소통하는 클래스 (CRUD 작업)

**Repository란?**
- 데이터 저장소와 소통하는 역할
- 데이터베이스 작업을 담당

**전체 구조**:
```java
@Repository
@RequiredArgsConstructor
public class BoardPersistRepository {
    
    private final EntityManager entityManager;
    
    // CRUD 메서드들...
}
```

**상세 설명**:

#### 5-1. EntityManager
```java
private final EntityManager entityManager;
```
- **의미**: JPA가 제공하는 데이터베이스 작업 도구
- **역할**: 
  - 데이터 저장, 조회, 수정, 삭제
  - SQL 쿼리 실행
- **DI**: Spring이 자동으로 주입

#### 5-2. save() - 저장
```java
@Transactional
public Board save(Board board) {
    entityManager.persist(board);
    return board;
}
```

**동작 과정**:
1. `@Transactional`: 트랜잭션 시작
2. `entityManager.persist(board)`: 데이터베이스에 저장
   - JPA가 자동으로 INSERT 쿼리 생성 및 실행
3. `return board`: 저장된 객체 반환 (ID가 자동 생성됨)

**왜 @Transactional을 쓰나?**
- 데이터베이스 작업은 트랜잭션 안에서 해야 안전
- 에러 발생 시 롤백 가능

#### 5-3. findAll() - 전체 조회
```java
public List<Board> findAll() {
    return entityManager
            .createQuery("SELECT b FROM Board b ORDER By b.createdAt DESC")
            .getResultList();
}
```

**동작 과정**:
1. `createQuery()`: JPQL 쿼리 생성
   - JPQL: Java Persistence Query Language
   - SQL과 비슷하지만 테이블 대신 엔티티 사용
2. `"SELECT b FROM Board b"`: Board 엔티티에서 모든 데이터 조회
3. `ORDER By b.createdAt DESC`: 작성일 기준 내림차순 정렬
4. `getResultList()`: 결과를 리스트로 반환

**왜 String을 반환하지 않나?**
- 데이터베이스에서 가져온 데이터를 반환해야 함
- `List<Board>`: 여러 개의 Board 객체를 담은 리스트

#### 5-4. findById() - 단건 조회
```java
public Board findById(Long id) {
    Board board = entityManager.find(Board.class, id);
    return board;
}
```

**동작 과정**:
1. `entityManager.find(Board.class, id)`: 
   - Board 클래스에서 id로 찾기
   - 자동으로 SELECT 쿼리 생성 및 실행
2. `return board`: 찾은 객체 반환 (없으면 null)

#### 5-5. updateById() - 수정
```java
@Transactional
public Board updateById(Long id, BoardRequest.UpdateDTO reqDTO) {
    Board board = entityManager.find(Board.class, id);
    if(board == null) {
        throw new IllegalArgumentException("수정할 게시글을 찾을 수 없어요");
    }
    board.update(reqDTO);
    return board;
}
```

**동작 과정**:
1. 게시글 조회
2. `board.update(reqDTO)`: Board 객체의 update 메서드 호출
3. **더티 체킹(Dirty Checking)**:
   - JPA가 엔티티의 변경사항을 자동으로 감지
   - 트랜잭션 종료 시 자동으로 UPDATE 쿼리 실행
   - 개발자가 직접 UPDATE 쿼리를 작성할 필요 없음

**더티 체킹의 장점**:
- 변경된 필드만 자동으로 UPDATE
- 코드가 간결해짐
- 실수로 UPDATE 쿼리를 빼먹을 일이 없음

#### 5-6. deleteById() - 삭제
```java
@Transactional
public void deleteById(Long id) {
    Board board = entityManager.find(Board.class, id);
    if(board == null) {
        throw new IllegalArgumentException("삭제할 게시글이 없어요");
    }
    entityManager.remove(board);
}
```

**동작 과정**:
1. 게시글 조회
2. `entityManager.remove(board)`: 삭제
   - JPA가 자동으로 DELETE 쿼리 생성 및 실행
3. `void`: 반환값 없음 (삭제만 수행)

---

## Mustache 템플릿 엔진

### Mustache란?

**Mustache**는 서버에서 HTML을 동적으로 생성하는 템플릿 엔진입니다.

- **템플릿 엔진**: HTML에 변수나 반복문을 넣어서 동적 페이지를 만드는 도구
- **역할**: Java 객체의 데이터를 HTML로 변환

### Mustache 문법

#### 1. 변수 출력
```mustache
{{board.title}}
```
- **의미**: `board` 객체의 `title` 필드 값을 출력
- **예시**: `{{board.title}}` → "안녕하세요" 출력

#### 2. 반복문
```mustache
{{#boardList}}
    <div>{{title}}</div>
{{/boardList}}
```
- **의미**: `boardList` 배열의 각 항목에 대해 반복
- **동작**:
  1. `boardList`의 첫 번째 항목
  2. `{{title}}` 출력
  3. 두 번째 항목으로 이동
  4. 반복...

#### 3. 조건문
```mustache
{{#board}}
    <div>게시글이 있습니다</div>
{{/board}}
```
- **의미**: `board`가 존재하면(true면) 내용 출력
- **false나 null이면**: 아무것도 출력 안 함

#### 4. 부분 템플릿 (Partial)
```mustache
{{> layout/header}}
```
- **의미**: `templates/layout/header.mustache` 파일을 불러와서 삽입
- **용도**: 공통 헤더, 푸터를 재사용

### 템플릿 파일 설명

#### 1. list.mustache (게시글 목록)
```mustache
{{> layout/header}}

<div class="container p-5">
    {{#boardList}}
    <div class="card mb-3">
        <div class="card-body">
            <h4 class="card-title mb-3">{{title}}</h4>
            <a href="/board/{{id}}" class="btn btn-primary">상세보기</a>
        </div>
    </div>
    {{/boardList}}
</div>

{{> layout/footer}}
```

**동작 과정**:
1. 헤더 삽입
2. `{{#boardList}}`: 컨트롤러에서 전달된 `boardList` 반복
3. 각 게시글마다 카드 생성
4. `{{title}}`: 게시글 제목 출력
5. `{{id}}`: 게시글 ID를 링크에 사용
6. 푸터 삽입

#### 2. detail.mustache (게시글 상세)
```mustache
{{> layout/header}}

<div class="container p-5">
    <h2><b>{{board.title}}</b></h2>
    <div>{{board.content}}</div>
    <b>작성자</b> : {{board.username}}
</div>

{{> layout/footer}}
```

**동작 과정**:
1. 컨트롤러에서 `model.addAttribute("board", board)`로 데이터 전달
2. `{{board.title}}`: 제목 출력
3. `{{board.content}}`: 내용 출력
4. `{{board.username}}`: 작성자 출력

#### 3. save-form.mustache (작성 폼)
```mustache
<form action="/board/save" method="post">
    <input type="text" name="username" placeholder="Enter username">
    <input type="text" name="title" placeholder="Enter title">
    <textarea name="content"></textarea>
    <button type="submit">글쓰기완료</button>
</form>
```

**동작 과정**:
1. `action="/board/save"`: 제출 시 `/board/save`로 POST 요청
2. `method="post"`: POST 방식으로 전송
3. `name="username"`: 서버에서 `username`으로 받음
4. 버튼 클릭 시 폼 데이터가 서버로 전송

**name 속성의 중요성**:
- `name="title"` → 컨트롤러의 `SaveDTO`의 `title` 필드와 매칭
- Spring이 자동으로 객체에 값 설정

#### 4. header.mustache (공통 헤더)
```mustache
<!DOCTYPE html>
<html>
<head>
    <title>Blog</title>
    <!-- CSS, JavaScript 링크 -->
</head>
<body>
<nav class="navbar">
    <!-- 네비게이션 바 -->
</nav>
```

**역할**: 모든 페이지에 공통으로 들어가는 헤더

#### 5. footer.mustache (공통 푸터)
```mustache
<div class="bg-light p-5 text-center">
    <h4>Created by Tencoding</h4>
</div>
</body>
</html>
```

**역할**: 모든 페이지에 공통으로 들어가는 푸터

---

## 전체 동작 흐름

### 시나리오 1: 게시글 목록 보기

1. **사용자**: 브라우저에서 `http://localhost:8080/board/list` 접속
2. **브라우저**: GET 요청을 서버로 전송
3. **Spring**: `@GetMapping("/board/list")`를 찾아서 `BoardController.boardList()` 실행
4. **Controller**: 
   - `repository.findAll()` 호출
   - 데이터베이스에서 모든 게시글 조회
   - `model.addAttribute("boardList", boardList)`로 데이터 전달
   - `return "board/list"`
5. **Spring**: `templates/board/list.mustache` 파일을 찾아서 렌더링
6. **Mustache**: 
   - `{{#boardList}}`로 반복문 실행
   - 각 게시글의 제목, 링크 등을 HTML로 생성
7. **서버**: 완성된 HTML을 브라우저로 전송
8. **브라우저**: HTML을 화면에 표시

### 시나리오 2: 게시글 작성하기

1. **사용자**: "글쓰기" 링크 클릭 → `/board/save` 접속
2. **Controller**: `saveFrom()` 실행 → `return "board/save-form"`
3. **브라우저**: 작성 폼 페이지 표시
4. **사용자**: 제목, 내용, 작성자 입력 후 "글쓰기완료" 버튼 클릭
5. **브라우저**: POST 요청을 `/board/save`로 전송
   - 요청 본문: `username=홍길동&title=제목&content=내용`
6. **Controller**: `saveProc(BoardRequest.SaveDTO saveDTO)` 실행
   - Spring이 자동으로 `SaveDTO` 객체 생성 및 값 설정
7. **Controller**: 
   - `saveDTO.toEntity()`로 `Board` 객체 생성
   - `repository.save(board)` 호출
8. **Repository**: 
   - `entityManager.persist(board)` 실행
   - 데이터베이스에 INSERT 쿼리 실행
9. **Controller**: `return "redirect:/"` → 목록 페이지로 이동
10. **브라우저**: 목록 페이지로 자동 이동

### 시나리오 3: 게시글 상세보기

1. **사용자**: 목록에서 "상세보기" 링크 클릭 → `/board/1` 접속
2. **Controller**: `detail(@PathVariable Long id, Model model)` 실행
   - `id = 1` (URL에서 추출)
3. **Controller**: 
   - `repository.findById(1)` 호출
   - 게시글 조회
   - `model.addAttribute("board", board)`로 데이터 전달
   - `return "board/detail"`
4. **Mustache**: 
   - `{{board.title}}` → 제목 출력
   - `{{board.content}}` → 내용 출력
   - `{{board.username}}` → 작성자 출력
5. **브라우저**: 상세 페이지 표시

### 시나리오 4: 게시글 수정하기

1. **사용자**: 상세 페이지에서 "수정" 버튼 클릭 → `/board/1/update` 접속
2. **Controller**: `updateForm()` 실행
   - 게시글 조회
   - 수정 폼에 기존 데이터 전달
3. **브라우저**: 수정 폼 페이지 표시 (기존 데이터가 입력되어 있음)
4. **사용자**: 내용 수정 후 "수정완료" 버튼 클릭
5. **Controller**: `updateProc()` 실행
   - `repository.updateById(id, updateDTO)` 호출
6. **Repository**: 
   - 게시글 조회
   - `board.update(updateDTO)` 호출
   - 더티 체킹으로 자동 UPDATE 쿼리 실행
7. **Controller**: `return "redirect:/board/list"` → 목록 페이지로 이동

### 시나리오 5: 게시글 삭제하기

1. **사용자**: 상세 페이지에서 "삭제" 버튼 클릭
2. **브라우저**: POST 요청을 `/board/1/delete`로 전송
3. **Controller**: `delete(@PathVariable Long id)` 실행
   - `repository.deleteById(1)` 호출
4. **Repository**: 
   - 게시글 조회
   - `entityManager.remove(board)` 실행
   - DELETE 쿼리 실행
5. **Controller**: `return "redirect:/"` → 목록 페이지로 이동

---

## 핵심 개념 정리

### 1. MVC 패턴

- **Model**: 데이터 (Board, BoardRequest 등)
- **View**: 화면 (Mustache 템플릿)
- **Controller**: 요청 처리 (BoardController)

### 2. 데이터 흐름

```
브라우저 → Controller → Repository → 데이터베이스
         ← Controller ← Repository ←
         ↓
      Mustache 템플릿 렌더링
         ↓
      HTML 반환
```

### 3. 어노테이션 역할 정리

| 어노테이션 | 역할 |
|----------|------|
| `@SpringBootApplication` | Spring Boot 시작점 |
| `@Controller` | 웹 요청 처리 |
| `@Repository` | 데이터베이스 작업 |
| `@Entity` | 데이터베이스 테이블 매핑 |
| `@GetMapping` | GET 요청 처리 |
| `@PostMapping` | POST 요청 처리 |
| `@PathVariable` | URL 경로에서 값 추출 |
| `@Transactional` | 트랜잭션 관리 |
| `@Data` | getter/setter 자동 생성 |
| `@RequiredArgsConstructor` | 생성자 자동 생성 |

### 4. 왜 void를 쓰는가? 왜 String을 쓰는가?

**void를 쓰는 경우**:
- 단순히 작업만 수행하고 결과를 반환할 필요가 없을 때
- 예: `deleteById()` - 삭제만 하고 끝

**String을 쓰는 경우**:
- 템플릿 파일 경로를 반환해야 할 때
- 예: `return "board/list"` - 어떤 페이지를 보여줄지 알려줌
- 리다이렉트를 할 때
- 예: `return "redirect:/"` - 다른 페이지로 이동

### 5. DTO vs Entity

**DTO (Data Transfer Object)**:
- 클라이언트와 서버 사이에서 데이터 전송
- 유효성 검사 포함
- 예: `BoardRequest.SaveDTO`

**Entity**:
- 데이터베이스 테이블과 직접 연결
- 비즈니스 로직 포함
- 예: `Board`

**왜 분리하나?**
- 보안: Entity의 모든 필드를 노출하지 않음
- 유연성: 요청/응답 형식을 자유롭게 변경 가능
- 책임 분리: 각각의 역할이 명확함

---

## 마무리

이 프로젝트는 Spring Boot와 Mustache를 사용한 기본적인 SSR 웹 애플리케이션입니다.

**핵심 포인트**:
1. **Controller**: 사용자 요청을 받아서 처리
2. **Repository**: 데이터베이스와 소통
3. **Entity**: 데이터베이스 테이블을 Java 클래스로 표현
4. **DTO**: 데이터 전송 객체
5. **Mustache**: 서버에서 HTML 생성
6. **어노테이션**: Spring이 자동으로 처리하도록 지시

**학습 순서 추천**:
1. Java 기본 문법 (public, String, void 등)
2. Spring Boot 기본 개념 (IoC, DI)
3. 어노테이션 이해
4. Controller → Repository → Entity 흐름 이해
5. Mustache 템플릿 문법
6. 전체 동작 흐름 파악

이 자료를 통해 Spring Boot와 Mustache의 기본을 이해할 수 있습니다!

